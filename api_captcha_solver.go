/*
 * TikHub Private API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * API version: 1.0.0
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package tikhub

import (
	_context "context"
	"github.com/antihax/optional"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
)

// Linger please
var (
	_ _context.Context
)

// CaptchaSolverApiService CaptchaSolverApi service
type CaptchaSolverApiService service

// CaptchaSolverApiAmazonCaptchaApiV1CaptchaAmazonCaptchaPostOpts Optional parameters for the method 'AmazonCaptchaApiV1CaptchaAmazonCaptchaPost'
type CaptchaSolverApiAmazonCaptchaApiV1CaptchaAmazonCaptchaPostOpts struct {
	BodyAmazonCaptchaApiV1CaptchaAmazonCaptchaPost optional.Interface
}

/*
AmazonCaptchaApiV1CaptchaAmazonCaptchaPost Amazon Captcha Solver/Amazon验证码解决器
# [中文] ### 用途: - Amazon Captcha验证码解决器 ### 参数: - app_id: 在HTML中可以找到网站对应的app_id - url: 需要解决验证码的URL - proxy: 默认为None ### 返回: - 返回验证码解决结果  # [English] ### Purpose: - Amazon Captcha solver ### Parameters: - app_id: The app_id corresponding to the website can be found in the HTML - url: URL that needs to solve the captcha - proxy: Default is None ### Return: - Return the captcha solution result  # [Example/示例] app_id &#x3D; \&quot;10000000\&quot; url &#x3D; \&quot;https://www.amazon.com/\&quot; proxy &#x3D; None
  - @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param optional nil or *CaptchaSolverApiAmazonCaptchaApiV1CaptchaAmazonCaptchaPostOpts - Optional Parameters:
  - @param "BodyAmazonCaptchaApiV1CaptchaAmazonCaptchaPost" (optional.Interface of BodyAmazonCaptchaApiV1CaptchaAmazonCaptchaPost) -

@return ResponseModel
*/
func (a *CaptchaSolverApiService) AmazonCaptchaApiV1CaptchaAmazonCaptchaPost(ctx _context.Context, localVarOptionals *CaptchaSolverApiAmazonCaptchaApiV1CaptchaAmazonCaptchaPostOpts) (ResponseModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResponseModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/captcha/amazon_captcha"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.BodyAmazonCaptchaApiV1CaptchaAmazonCaptchaPost.IsSet() {
		localVarOptionalBodyAmazonCaptchaApiV1CaptchaAmazonCaptchaPost, localVarOptionalBodyAmazonCaptchaApiV1CaptchaAmazonCaptchaPostok := localVarOptionals.BodyAmazonCaptchaApiV1CaptchaAmazonCaptchaPost.Value().(BodyAmazonCaptchaApiV1CaptchaAmazonCaptchaPost)
		if !localVarOptionalBodyAmazonCaptchaApiV1CaptchaAmazonCaptchaPostok {
			return localVarReturnValue, nil, reportError("bodyAmazonCaptchaApiV1CaptchaAmazonCaptchaPost should be BodyAmazonCaptchaApiV1CaptchaAmazonCaptchaPost")
		}
		localVarPostBody = &localVarOptionalBodyAmazonCaptchaApiV1CaptchaAmazonCaptchaPost
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// CaptchaSolverApiAmazonCaptchaApiV1CaptchaAmazonCaptchaPost_1Opts Optional parameters for the method 'AmazonCaptchaApiV1CaptchaAmazonCaptchaPost_1'
type CaptchaSolverApiAmazonCaptchaApiV1CaptchaAmazonCaptchaPost_1Opts struct {
	BodyAmazonCaptchaApiV1CaptchaAmazonCaptchaPost optional.Interface
}

/*
AmazonCaptchaApiV1CaptchaAmazonCaptchaPost_0 Amazon Captcha Solver/Amazon验证码解决器
# [中文] ### 用途: - Amazon Captcha验证码解决器 ### 参数: - app_id: 在HTML中可以找到网站对应的app_id - url: 需要解决验证码的URL - proxy: 默认为None ### 返回: - 返回验证码解决结果  # [English] ### Purpose: - Amazon Captcha solver ### Parameters: - app_id: The app_id corresponding to the website can be found in the HTML - url: URL that needs to solve the captcha - proxy: Default is None ### Return: - Return the captcha solution result  # [Example/示例] app_id &#x3D; \&quot;10000000\&quot; url &#x3D; \&quot;https://www.amazon.com/\&quot; proxy &#x3D; None
  - @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param optional nil or *CaptchaSolverApiAmazonCaptchaApiV1CaptchaAmazonCaptchaPost_1Opts - Optional Parameters:
  - @param "BodyAmazonCaptchaApiV1CaptchaAmazonCaptchaPost" (optional.Interface of BodyAmazonCaptchaApiV1CaptchaAmazonCaptchaPost) -

@return ResponseModel
*/
func (a *CaptchaSolverApiService) AmazonCaptchaApiV1CaptchaAmazonCaptchaPost_1(ctx _context.Context, localVarOptionals *CaptchaSolverApiAmazonCaptchaApiV1CaptchaAmazonCaptchaPost_1Opts) (ResponseModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResponseModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/captcha/amazon_captcha"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.BodyAmazonCaptchaApiV1CaptchaAmazonCaptchaPost.IsSet() {
		localVarOptionalBodyAmazonCaptchaApiV1CaptchaAmazonCaptchaPost, localVarOptionalBodyAmazonCaptchaApiV1CaptchaAmazonCaptchaPostok := localVarOptionals.BodyAmazonCaptchaApiV1CaptchaAmazonCaptchaPost.Value().(BodyAmazonCaptchaApiV1CaptchaAmazonCaptchaPost)
		if !localVarOptionalBodyAmazonCaptchaApiV1CaptchaAmazonCaptchaPostok {
			return localVarReturnValue, nil, reportError("bodyAmazonCaptchaApiV1CaptchaAmazonCaptchaPost should be BodyAmazonCaptchaApiV1CaptchaAmazonCaptchaPost")
		}
		localVarPostBody = &localVarOptionalBodyAmazonCaptchaApiV1CaptchaAmazonCaptchaPost
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// CaptchaSolverApiCloudflareTurnstileApiV1CaptchaCloudflareTurnstilePostOpts Optional parameters for the method 'CloudflareTurnstileApiV1CaptchaCloudflareTurnstilePost'
type CaptchaSolverApiCloudflareTurnstileApiV1CaptchaCloudflareTurnstilePostOpts struct {
	BodyCloudflareTurnstileApiV1CaptchaCloudflareTurnstilePost optional.Interface
}

/*
CloudflareTurnstileApiV1CaptchaCloudflareTurnstilePost Cloudflare Turnstile Solver/Cloudflare Turnstile解决器
# [中文] ### 用途: - Cloudflare Turnstile验证码解决器 ### 参数: - sitekey: 在HTML中可以找到网站对应的sitekey - url: 需要解决验证码的URL - proxy: 默认为None ### 返回: - 返回验证码解决结果  # [English] ### Purpose: - Cloudflare Turnstile captcha solver ### Parameters: - sitekey: The sitekey corresponding to the website can be found in the HTML - url: URL that needs to solve the captcha - action: Default is None - data: Default is None - proxy: Default is None ### Return: - Return the captcha solution result  # [Example/示例] sitekey &#x3D; \&quot;1x00000000000000000000AA\&quot; url &#x3D; \&quot;https://demo.turnstile.workers.dev\&quot; proxy &#x3D; None
  - @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param optional nil or *CaptchaSolverApiCloudflareTurnstileApiV1CaptchaCloudflareTurnstilePostOpts - Optional Parameters:
  - @param "BodyCloudflareTurnstileApiV1CaptchaCloudflareTurnstilePost" (optional.Interface of BodyCloudflareTurnstileApiV1CaptchaCloudflareTurnstilePost) -

@return ResponseModel
*/
func (a *CaptchaSolverApiService) CloudflareTurnstileApiV1CaptchaCloudflareTurnstilePost(ctx _context.Context, localVarOptionals *CaptchaSolverApiCloudflareTurnstileApiV1CaptchaCloudflareTurnstilePostOpts) (ResponseModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResponseModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/captcha/cloudflare_turnstile"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.BodyCloudflareTurnstileApiV1CaptchaCloudflareTurnstilePost.IsSet() {
		localVarOptionalBodyCloudflareTurnstileApiV1CaptchaCloudflareTurnstilePost, localVarOptionalBodyCloudflareTurnstileApiV1CaptchaCloudflareTurnstilePostok := localVarOptionals.BodyCloudflareTurnstileApiV1CaptchaCloudflareTurnstilePost.Value().(BodyCloudflareTurnstileApiV1CaptchaCloudflareTurnstilePost)
		if !localVarOptionalBodyCloudflareTurnstileApiV1CaptchaCloudflareTurnstilePostok {
			return localVarReturnValue, nil, reportError("bodyCloudflareTurnstileApiV1CaptchaCloudflareTurnstilePost should be BodyCloudflareTurnstileApiV1CaptchaCloudflareTurnstilePost")
		}
		localVarPostBody = &localVarOptionalBodyCloudflareTurnstileApiV1CaptchaCloudflareTurnstilePost
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// CaptchaSolverApiCloudflareTurnstileApiV1CaptchaCloudflareTurnstilePost_2Opts Optional parameters for the method 'CloudflareTurnstileApiV1CaptchaCloudflareTurnstilePost_2'
type CaptchaSolverApiCloudflareTurnstileApiV1CaptchaCloudflareTurnstilePost_2Opts struct {
	BodyCloudflareTurnstileApiV1CaptchaCloudflareTurnstilePost optional.Interface
}

/*
CloudflareTurnstileApiV1CaptchaCloudflareTurnstilePost_0 Cloudflare Turnstile Solver/Cloudflare Turnstile解决器
# [中文] ### 用途: - Cloudflare Turnstile验证码解决器 ### 参数: - sitekey: 在HTML中可以找到网站对应的sitekey - url: 需要解决验证码的URL - proxy: 默认为None ### 返回: - 返回验证码解决结果  # [English] ### Purpose: - Cloudflare Turnstile captcha solver ### Parameters: - sitekey: The sitekey corresponding to the website can be found in the HTML - url: URL that needs to solve the captcha - action: Default is None - data: Default is None - proxy: Default is None ### Return: - Return the captcha solution result  # [Example/示例] sitekey &#x3D; \&quot;1x00000000000000000000AA\&quot; url &#x3D; \&quot;https://demo.turnstile.workers.dev\&quot; proxy &#x3D; None
  - @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param optional nil or *CaptchaSolverApiCloudflareTurnstileApiV1CaptchaCloudflareTurnstilePost_2Opts - Optional Parameters:
  - @param "BodyCloudflareTurnstileApiV1CaptchaCloudflareTurnstilePost" (optional.Interface of BodyCloudflareTurnstileApiV1CaptchaCloudflareTurnstilePost) -

@return ResponseModel
*/
func (a *CaptchaSolverApiService) CloudflareTurnstileApiV1CaptchaCloudflareTurnstilePost_2(ctx _context.Context, localVarOptionals *CaptchaSolverApiCloudflareTurnstileApiV1CaptchaCloudflareTurnstilePost_2Opts) (ResponseModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResponseModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/captcha/cloudflare_turnstile"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.BodyCloudflareTurnstileApiV1CaptchaCloudflareTurnstilePost.IsSet() {
		localVarOptionalBodyCloudflareTurnstileApiV1CaptchaCloudflareTurnstilePost, localVarOptionalBodyCloudflareTurnstileApiV1CaptchaCloudflareTurnstilePostok := localVarOptionals.BodyCloudflareTurnstileApiV1CaptchaCloudflareTurnstilePost.Value().(BodyCloudflareTurnstileApiV1CaptchaCloudflareTurnstilePost)
		if !localVarOptionalBodyCloudflareTurnstileApiV1CaptchaCloudflareTurnstilePostok {
			return localVarReturnValue, nil, reportError("bodyCloudflareTurnstileApiV1CaptchaCloudflareTurnstilePost should be BodyCloudflareTurnstileApiV1CaptchaCloudflareTurnstilePost")
		}
		localVarPostBody = &localVarOptionalBodyCloudflareTurnstileApiV1CaptchaCloudflareTurnstilePost
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// CaptchaSolverApiHcaptchaApiV1CaptchaHcaptchaPostOpts Optional parameters for the method 'HcaptchaApiV1CaptchaHcaptchaPost'
type CaptchaSolverApiHcaptchaApiV1CaptchaHcaptchaPostOpts struct {
	BodyHcaptchaApiV1CaptchaHcaptchaPost optional.Interface
}

/*
HcaptchaApiV1CaptchaHcaptchaPost hCaptcha Solver/hCaptcha解决器
# [中文] ### 用途: - hCaptcha验证码解决器 ### 参数: - sitekey: 在HTML中可以找到网站对应的sitekey - url: 需要解决验证码的URL - proxy: 默认为None ### 返回: - 返回验证码解决结果  # [English] ### Purpose: - hCaptcha captcha solver ### Parameters: - sitekey: The sitekey corresponding to the website can be found in the HTML - url: URL that needs to solve the captcha - proxy: Default is None ### Return: - Return the captcha solution result  # [Example/示例] sitekey &#x3D; \&quot;10000000-ffff-ffff-ffff-000000000001\&quot; url &#x3D; \&quot;https://www.hcaptcha.com/\&quot; proxy &#x3D; None
  - @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param optional nil or *CaptchaSolverApiHcaptchaApiV1CaptchaHcaptchaPostOpts - Optional Parameters:
  - @param "BodyHcaptchaApiV1CaptchaHcaptchaPost" (optional.Interface of BodyHcaptchaApiV1CaptchaHcaptchaPost) -

@return ResponseModel
*/
func (a *CaptchaSolverApiService) HcaptchaApiV1CaptchaHcaptchaPost(ctx _context.Context, localVarOptionals *CaptchaSolverApiHcaptchaApiV1CaptchaHcaptchaPostOpts) (ResponseModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResponseModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/captcha/hcaptcha"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.BodyHcaptchaApiV1CaptchaHcaptchaPost.IsSet() {
		localVarOptionalBodyHcaptchaApiV1CaptchaHcaptchaPost, localVarOptionalBodyHcaptchaApiV1CaptchaHcaptchaPostok := localVarOptionals.BodyHcaptchaApiV1CaptchaHcaptchaPost.Value().(BodyHcaptchaApiV1CaptchaHcaptchaPost)
		if !localVarOptionalBodyHcaptchaApiV1CaptchaHcaptchaPostok {
			return localVarReturnValue, nil, reportError("bodyHcaptchaApiV1CaptchaHcaptchaPost should be BodyHcaptchaApiV1CaptchaHcaptchaPost")
		}
		localVarPostBody = &localVarOptionalBodyHcaptchaApiV1CaptchaHcaptchaPost
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// CaptchaSolverApiHcaptchaApiV1CaptchaHcaptchaPost_3Opts Optional parameters for the method 'HcaptchaApiV1CaptchaHcaptchaPost_3'
type CaptchaSolverApiHcaptchaApiV1CaptchaHcaptchaPost_3Opts struct {
	BodyHcaptchaApiV1CaptchaHcaptchaPost optional.Interface
}

/*
HcaptchaApiV1CaptchaHcaptchaPost_0 hCaptcha Solver/hCaptcha解决器
# [中文] ### 用途: - hCaptcha验证码解决器 ### 参数: - sitekey: 在HTML中可以找到网站对应的sitekey - url: 需要解决验证码的URL - proxy: 默认为None ### 返回: - 返回验证码解决结果  # [English] ### Purpose: - hCaptcha captcha solver ### Parameters: - sitekey: The sitekey corresponding to the website can be found in the HTML - url: URL that needs to solve the captcha - proxy: Default is None ### Return: - Return the captcha solution result  # [Example/示例] sitekey &#x3D; \&quot;10000000-ffff-ffff-ffff-000000000001\&quot; url &#x3D; \&quot;https://www.hcaptcha.com/\&quot; proxy &#x3D; None
  - @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param optional nil or *CaptchaSolverApiHcaptchaApiV1CaptchaHcaptchaPost_3Opts - Optional Parameters:
  - @param "BodyHcaptchaApiV1CaptchaHcaptchaPost" (optional.Interface of BodyHcaptchaApiV1CaptchaHcaptchaPost) -

@return ResponseModel
*/
func (a *CaptchaSolverApiService) HcaptchaApiV1CaptchaHcaptchaPost_3(ctx _context.Context, localVarOptionals *CaptchaSolverApiHcaptchaApiV1CaptchaHcaptchaPost_3Opts) (ResponseModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResponseModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/captcha/hcaptcha"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.BodyHcaptchaApiV1CaptchaHcaptchaPost.IsSet() {
		localVarOptionalBodyHcaptchaApiV1CaptchaHcaptchaPost, localVarOptionalBodyHcaptchaApiV1CaptchaHcaptchaPostok := localVarOptionals.BodyHcaptchaApiV1CaptchaHcaptchaPost.Value().(BodyHcaptchaApiV1CaptchaHcaptchaPost)
		if !localVarOptionalBodyHcaptchaApiV1CaptchaHcaptchaPostok {
			return localVarReturnValue, nil, reportError("bodyHcaptchaApiV1CaptchaHcaptchaPost should be BodyHcaptchaApiV1CaptchaHcaptchaPost")
		}
		localVarPostBody = &localVarOptionalBodyHcaptchaApiV1CaptchaHcaptchaPost
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// CaptchaSolverApiRecaptchaV2ApiV1CaptchaRecaptchaV2PostOpts Optional parameters for the method 'RecaptchaV2ApiV1CaptchaRecaptchaV2Post'
type CaptchaSolverApiRecaptchaV2ApiV1CaptchaRecaptchaV2PostOpts struct {
	BodyRecaptchaV2ApiV1CaptchaRecaptchaV2Post optional.Interface
}

/*
RecaptchaV2ApiV1CaptchaRecaptchaV2Post Recaptcha V2 Solver/Recaptcha V2解决器
# [中文] ### 用途: - Recaptcha V2验证码解决器 ### 参数: - sitekey: 在HTML中可以找到网站对应的sitekey - url: 需要解决验证码的URL - proxy: 默认为None ### 返回: - 返回验证码解决结果  # [English] ### Purpose: - Recaptcha V2 captcha solver ### Parameters: - sitekey: The sitekey corresponding to the website can be found in the HTML - url: URL that needs to solve the captcha - proxy: Default is None ### Return: - Return the captcha solution result  # [Example/示例] sitekey &#x3D; \&quot;6Le-wvkSAAAAAPBMRTvw0Q4Muexq9bi0DJwx_mJ-\&quot; url &#x3D; \&quot;https://www.google.com/recaptcha/api2/demo\&quot; proxy &#x3D; None
  - @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param optional nil or *CaptchaSolverApiRecaptchaV2ApiV1CaptchaRecaptchaV2PostOpts - Optional Parameters:
  - @param "BodyRecaptchaV2ApiV1CaptchaRecaptchaV2Post" (optional.Interface of BodyRecaptchaV2ApiV1CaptchaRecaptchaV2Post) -

@return ResponseModel
*/
func (a *CaptchaSolverApiService) RecaptchaV2ApiV1CaptchaRecaptchaV2Post(ctx _context.Context, localVarOptionals *CaptchaSolverApiRecaptchaV2ApiV1CaptchaRecaptchaV2PostOpts) (ResponseModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResponseModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/captcha/recaptcha_v2"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.BodyRecaptchaV2ApiV1CaptchaRecaptchaV2Post.IsSet() {
		localVarOptionalBodyRecaptchaV2ApiV1CaptchaRecaptchaV2Post, localVarOptionalBodyRecaptchaV2ApiV1CaptchaRecaptchaV2Postok := localVarOptionals.BodyRecaptchaV2ApiV1CaptchaRecaptchaV2Post.Value().(BodyRecaptchaV2ApiV1CaptchaRecaptchaV2Post)
		if !localVarOptionalBodyRecaptchaV2ApiV1CaptchaRecaptchaV2Postok {
			return localVarReturnValue, nil, reportError("bodyRecaptchaV2ApiV1CaptchaRecaptchaV2Post should be BodyRecaptchaV2ApiV1CaptchaRecaptchaV2Post")
		}
		localVarPostBody = &localVarOptionalBodyRecaptchaV2ApiV1CaptchaRecaptchaV2Post
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// CaptchaSolverApiRecaptchaV2ApiV1CaptchaRecaptchaV2Post_4Opts Optional parameters for the method 'RecaptchaV2ApiV1CaptchaRecaptchaV2Post_4'
type CaptchaSolverApiRecaptchaV2ApiV1CaptchaRecaptchaV2Post_4Opts struct {
	BodyRecaptchaV2ApiV1CaptchaRecaptchaV2Post optional.Interface
}

/*
RecaptchaV2ApiV1CaptchaRecaptchaV2Post_0 Recaptcha V2 Solver/Recaptcha V2解决器
# [中文] ### 用途: - Recaptcha V2验证码解决器 ### 参数: - sitekey: 在HTML中可以找到网站对应的sitekey - url: 需要解决验证码的URL - proxy: 默认为None ### 返回: - 返回验证码解决结果  # [English] ### Purpose: - Recaptcha V2 captcha solver ### Parameters: - sitekey: The sitekey corresponding to the website can be found in the HTML - url: URL that needs to solve the captcha - proxy: Default is None ### Return: - Return the captcha solution result  # [Example/示例] sitekey &#x3D; \&quot;6Le-wvkSAAAAAPBMRTvw0Q4Muexq9bi0DJwx_mJ-\&quot; url &#x3D; \&quot;https://www.google.com/recaptcha/api2/demo\&quot; proxy &#x3D; None
  - @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param optional nil or *CaptchaSolverApiRecaptchaV2ApiV1CaptchaRecaptchaV2Post_4Opts - Optional Parameters:
  - @param "BodyRecaptchaV2ApiV1CaptchaRecaptchaV2Post" (optional.Interface of BodyRecaptchaV2ApiV1CaptchaRecaptchaV2Post) -

@return ResponseModel
*/
func (a *CaptchaSolverApiService) RecaptchaV2ApiV1CaptchaRecaptchaV2Post_4(ctx _context.Context, localVarOptionals *CaptchaSolverApiRecaptchaV2ApiV1CaptchaRecaptchaV2Post_4Opts) (ResponseModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResponseModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/captcha/recaptcha_v2"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.BodyRecaptchaV2ApiV1CaptchaRecaptchaV2Post.IsSet() {
		localVarOptionalBodyRecaptchaV2ApiV1CaptchaRecaptchaV2Post, localVarOptionalBodyRecaptchaV2ApiV1CaptchaRecaptchaV2Postok := localVarOptionals.BodyRecaptchaV2ApiV1CaptchaRecaptchaV2Post.Value().(BodyRecaptchaV2ApiV1CaptchaRecaptchaV2Post)
		if !localVarOptionalBodyRecaptchaV2ApiV1CaptchaRecaptchaV2Postok {
			return localVarReturnValue, nil, reportError("bodyRecaptchaV2ApiV1CaptchaRecaptchaV2Post should be BodyRecaptchaV2ApiV1CaptchaRecaptchaV2Post")
		}
		localVarPostBody = &localVarOptionalBodyRecaptchaV2ApiV1CaptchaRecaptchaV2Post
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// CaptchaSolverApiRecaptchaV3ApiV1CaptchaRecaptchaV3PostOpts Optional parameters for the method 'RecaptchaV3ApiV1CaptchaRecaptchaV3Post'
type CaptchaSolverApiRecaptchaV3ApiV1CaptchaRecaptchaV3PostOpts struct {
	BodyRecaptchaV3ApiV1CaptchaRecaptchaV3Post optional.Interface
}

/*
RecaptchaV3ApiV1CaptchaRecaptchaV3Post Recaptcha V3 Solver/Recaptcha V3解决器
# [中文] ### 用途: - Recaptcha V3验证码解决器 ### 参数: - sitekey: 在HTML中可以找到网站对应的sitekey - url: 需要解决验证码的URL - proxy: 默认为None ### 返回: - 返回验证码解决结果  # [English] ### Purpose: - Recaptcha V3 captcha solver ### Parameters: - sitekey: The sitekey corresponding to the website can be found in the HTML - url: URL that needs to solve the captcha - proxy: Default is None ### Return: - Return the captcha solution result  # [Example/示例] sitekey &#x3D; \&quot;6Le-wvkSAAAAAPBMRTvw0Q4Muexq9bi0DJwx_mJ-\&quot; url &#x3D; \&quot;https://www.google.com/recaptcha/api2/demo\&quot; proxy &#x3D; None
  - @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param optional nil or *CaptchaSolverApiRecaptchaV3ApiV1CaptchaRecaptchaV3PostOpts - Optional Parameters:
  - @param "BodyRecaptchaV3ApiV1CaptchaRecaptchaV3Post" (optional.Interface of BodyRecaptchaV3ApiV1CaptchaRecaptchaV3Post) -

@return ResponseModel
*/
func (a *CaptchaSolverApiService) RecaptchaV3ApiV1CaptchaRecaptchaV3Post(ctx _context.Context, localVarOptionals *CaptchaSolverApiRecaptchaV3ApiV1CaptchaRecaptchaV3PostOpts) (ResponseModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResponseModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/captcha/recaptcha_v3"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.BodyRecaptchaV3ApiV1CaptchaRecaptchaV3Post.IsSet() {
		localVarOptionalBodyRecaptchaV3ApiV1CaptchaRecaptchaV3Post, localVarOptionalBodyRecaptchaV3ApiV1CaptchaRecaptchaV3Postok := localVarOptionals.BodyRecaptchaV3ApiV1CaptchaRecaptchaV3Post.Value().(BodyRecaptchaV3ApiV1CaptchaRecaptchaV3Post)
		if !localVarOptionalBodyRecaptchaV3ApiV1CaptchaRecaptchaV3Postok {
			return localVarReturnValue, nil, reportError("bodyRecaptchaV3ApiV1CaptchaRecaptchaV3Post should be BodyRecaptchaV3ApiV1CaptchaRecaptchaV3Post")
		}
		localVarPostBody = &localVarOptionalBodyRecaptchaV3ApiV1CaptchaRecaptchaV3Post
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// CaptchaSolverApiRecaptchaV3ApiV1CaptchaRecaptchaV3Post_5Opts Optional parameters for the method 'RecaptchaV3ApiV1CaptchaRecaptchaV3Post_5'
type CaptchaSolverApiRecaptchaV3ApiV1CaptchaRecaptchaV3Post_5Opts struct {
	BodyRecaptchaV3ApiV1CaptchaRecaptchaV3Post optional.Interface
}

/*
RecaptchaV3ApiV1CaptchaRecaptchaV3Post_0 Recaptcha V3 Solver/Recaptcha V3解决器
# [中文] ### 用途: - Recaptcha V3验证码解决器 ### 参数: - sitekey: 在HTML中可以找到网站对应的sitekey - url: 需要解决验证码的URL - proxy: 默认为None ### 返回: - 返回验证码解决结果  # [English] ### Purpose: - Recaptcha V3 captcha solver ### Parameters: - sitekey: The sitekey corresponding to the website can be found in the HTML - url: URL that needs to solve the captcha - proxy: Default is None ### Return: - Return the captcha solution result  # [Example/示例] sitekey &#x3D; \&quot;6Le-wvkSAAAAAPBMRTvw0Q4Muexq9bi0DJwx_mJ-\&quot; url &#x3D; \&quot;https://www.google.com/recaptcha/api2/demo\&quot; proxy &#x3D; None
  - @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param optional nil or *CaptchaSolverApiRecaptchaV3ApiV1CaptchaRecaptchaV3Post_5Opts - Optional Parameters:
  - @param "BodyRecaptchaV3ApiV1CaptchaRecaptchaV3Post" (optional.Interface of BodyRecaptchaV3ApiV1CaptchaRecaptchaV3Post) -

@return ResponseModel
*/
func (a *CaptchaSolverApiService) RecaptchaV3ApiV1CaptchaRecaptchaV3Post_5(ctx _context.Context, localVarOptionals *CaptchaSolverApiRecaptchaV3ApiV1CaptchaRecaptchaV3Post_5Opts) (ResponseModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResponseModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/captcha/recaptcha_v3"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.BodyRecaptchaV3ApiV1CaptchaRecaptchaV3Post.IsSet() {
		localVarOptionalBodyRecaptchaV3ApiV1CaptchaRecaptchaV3Post, localVarOptionalBodyRecaptchaV3ApiV1CaptchaRecaptchaV3Postok := localVarOptionals.BodyRecaptchaV3ApiV1CaptchaRecaptchaV3Post.Value().(BodyRecaptchaV3ApiV1CaptchaRecaptchaV3Post)
		if !localVarOptionalBodyRecaptchaV3ApiV1CaptchaRecaptchaV3Postok {
			return localVarReturnValue, nil, reportError("bodyRecaptchaV3ApiV1CaptchaRecaptchaV3Post should be BodyRecaptchaV3ApiV1CaptchaRecaptchaV3Post")
		}
		localVarPostBody = &localVarOptionalBodyRecaptchaV3ApiV1CaptchaRecaptchaV3Post
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// CaptchaSolverApiTencentCaptchaApiV1CaptchaTencentCaptchaPostOpts Optional parameters for the method 'TencentCaptchaApiV1CaptchaTencentCaptchaPost'
type CaptchaSolverApiTencentCaptchaApiV1CaptchaTencentCaptchaPostOpts struct {
	BodyTencentCaptchaApiV1CaptchaTencentCaptchaPost optional.Interface
}

/*
TencentCaptchaApiV1CaptchaTencentCaptchaPost Tencent Captcha Solver/Tencent验证码解决器
# [中文] ### 用途: - Tencent Captcha验证码解决器 ### 参数: - app_id: 在HTML中可以找到网站对应的app_id - url: 需要解决验证码的URL - proxy: 默认为None ### 返回: - 返回验证码解决结果  # [English] ### Purpose: - Tencent Captcha solver ### Parameters: - app_id: The app_id corresponding to the website can be found in the HTML - url: URL that needs to solve the captcha - proxy: Default is None ### Return: - Return the captcha solution result  # [Example/示例] app_id &#x3D; \&quot;10000000\&quot; url &#x3D; \&quot;https://www.tencent.com/\&quot; proxy &#x3D; None
  - @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param optional nil or *CaptchaSolverApiTencentCaptchaApiV1CaptchaTencentCaptchaPostOpts - Optional Parameters:
  - @param "BodyTencentCaptchaApiV1CaptchaTencentCaptchaPost" (optional.Interface of BodyTencentCaptchaApiV1CaptchaTencentCaptchaPost) -

@return ResponseModel
*/
func (a *CaptchaSolverApiService) TencentCaptchaApiV1CaptchaTencentCaptchaPost(ctx _context.Context, localVarOptionals *CaptchaSolverApiTencentCaptchaApiV1CaptchaTencentCaptchaPostOpts) (ResponseModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResponseModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/captcha/tencent_captcha"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.BodyTencentCaptchaApiV1CaptchaTencentCaptchaPost.IsSet() {
		localVarOptionalBodyTencentCaptchaApiV1CaptchaTencentCaptchaPost, localVarOptionalBodyTencentCaptchaApiV1CaptchaTencentCaptchaPostok := localVarOptionals.BodyTencentCaptchaApiV1CaptchaTencentCaptchaPost.Value().(BodyTencentCaptchaApiV1CaptchaTencentCaptchaPost)
		if !localVarOptionalBodyTencentCaptchaApiV1CaptchaTencentCaptchaPostok {
			return localVarReturnValue, nil, reportError("bodyTencentCaptchaApiV1CaptchaTencentCaptchaPost should be BodyTencentCaptchaApiV1CaptchaTencentCaptchaPost")
		}
		localVarPostBody = &localVarOptionalBodyTencentCaptchaApiV1CaptchaTencentCaptchaPost
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// CaptchaSolverApiTencentCaptchaApiV1CaptchaTencentCaptchaPost_6Opts Optional parameters for the method 'TencentCaptchaApiV1CaptchaTencentCaptchaPost_6'
type CaptchaSolverApiTencentCaptchaApiV1CaptchaTencentCaptchaPost_6Opts struct {
	BodyTencentCaptchaApiV1CaptchaTencentCaptchaPost optional.Interface
}

/*
TencentCaptchaApiV1CaptchaTencentCaptchaPost_0 Tencent Captcha Solver/Tencent验证码解决器
# [中文] ### 用途: - Tencent Captcha验证码解决器 ### 参数: - app_id: 在HTML中可以找到网站对应的app_id - url: 需要解决验证码的URL - proxy: 默认为None ### 返回: - 返回验证码解决结果  # [English] ### Purpose: - Tencent Captcha solver ### Parameters: - app_id: The app_id corresponding to the website can be found in the HTML - url: URL that needs to solve the captcha - proxy: Default is None ### Return: - Return the captcha solution result  # [Example/示例] app_id &#x3D; \&quot;10000000\&quot; url &#x3D; \&quot;https://www.tencent.com/\&quot; proxy &#x3D; None
  - @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param optional nil or *CaptchaSolverApiTencentCaptchaApiV1CaptchaTencentCaptchaPost_6Opts - Optional Parameters:
  - @param "BodyTencentCaptchaApiV1CaptchaTencentCaptchaPost" (optional.Interface of BodyTencentCaptchaApiV1CaptchaTencentCaptchaPost) -

@return ResponseModel
*/
func (a *CaptchaSolverApiService) TencentCaptchaApiV1CaptchaTencentCaptchaPost_6(ctx _context.Context, localVarOptionals *CaptchaSolverApiTencentCaptchaApiV1CaptchaTencentCaptchaPost_6Opts) (ResponseModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResponseModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/captcha/tencent_captcha"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.BodyTencentCaptchaApiV1CaptchaTencentCaptchaPost.IsSet() {
		localVarOptionalBodyTencentCaptchaApiV1CaptchaTencentCaptchaPost, localVarOptionalBodyTencentCaptchaApiV1CaptchaTencentCaptchaPostok := localVarOptionals.BodyTencentCaptchaApiV1CaptchaTencentCaptchaPost.Value().(BodyTencentCaptchaApiV1CaptchaTencentCaptchaPost)
		if !localVarOptionalBodyTencentCaptchaApiV1CaptchaTencentCaptchaPostok {
			return localVarReturnValue, nil, reportError("bodyTencentCaptchaApiV1CaptchaTencentCaptchaPost should be BodyTencentCaptchaApiV1CaptchaTencentCaptchaPost")
		}
		localVarPostBody = &localVarOptionalBodyTencentCaptchaApiV1CaptchaTencentCaptchaPost
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
