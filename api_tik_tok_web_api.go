/*
 * TikHub Private API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * API version: 1.0.0
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package tikhub

import (
	_context "context"
	"github.com/antihax/optional"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
)

// Linger please
var (
	_ _context.Context
)

// TikTokWebAPIApiService TikTokWebAPIApi service
type TikTokWebAPIApiService service

/*
DouyinLiveRoomApiV1TiktokWebTiktokLiveRoomGet 提取直播间弹幕/Extract live room danmaku
# [中文] ### 用途: - 提取直播间弹幕 #### 价格: - 每10条数据消耗0.001$，支持阶梯式计费折扣。 ### 参数: - live_room_url: 直播间链接 - danmaku_type: 消息类型     - WebcastChatMessage: 聊天消息     - WebcastMemberMessage: 成员消息     - WebcastRoomUserSeqMessage: 用户序列消息     - WebcastGiftMessage: 礼物消息     - WebcastSocialMessage: 社交消息     - WebcastLikeMessage: 点赞消息     - WebcastLinkMicFanTicketMethod: 连麦粉丝票方法     - WebcastLinkMicMethod: 连麦方法 ### 返回: - 弹幕数据的WebSocket连接信息，需要使用WebSocket连接获取弹幕数据，此接口不返回弹幕数据。  # [English] ### Purpose: - Extract live room danmaku #### Price: - 0.001$ per 10 data, support tiered billing discount. ### Parameters: - live_room_url: Live room link - danmaku_type: Message type     - WebcastChatMessage: Chat message     - WebcastMemberMessage: Member message     - WebcastRoomUserSeqMessage: User sequence message     - WebcastGiftMessage: Gift message     - WebcastSocialMessage: Social message     - WebcastLikeMessage: Like message     - WebcastLinkMicFanTicketMethod: Link Mic Fan Ticket Method     - WebcastLinkMicMethod: Link Mic Method ### Return: - WebSocket connection information of the danmaku data, you need to use WebSocket connection to get the danmaku data, this interface does not return the danmaku data.
  - @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param liveRoomUrl 直播间链接/Live room link
  - @param danmakuType 消息类型/Message type

@return ResponseModel
*/
func (a *TikTokWebAPIApiService) DouyinLiveRoomApiV1TiktokWebTiktokLiveRoomGet(ctx _context.Context, liveRoomUrl string, danmakuType string) (ResponseModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResponseModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/tiktok/web/tiktok_live_room"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	localVarQueryParams.Add("live_room_url", parameterToString(liveRoomUrl, ""))
	localVarQueryParams.Add("danmaku_type", parameterToString(danmakuType, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
DouyinLiveRoomApiV1TiktokWebTiktokLiveRoomGet_0 提取直播间弹幕/Extract live room danmaku
# [中文] ### 用途: - 提取直播间弹幕 #### 价格: - 每10条数据消耗0.001$，支持阶梯式计费折扣。 ### 参数: - live_room_url: 直播间链接 - danmaku_type: 消息类型     - WebcastChatMessage: 聊天消息     - WebcastMemberMessage: 成员消息     - WebcastRoomUserSeqMessage: 用户序列消息     - WebcastGiftMessage: 礼物消息     - WebcastSocialMessage: 社交消息     - WebcastLikeMessage: 点赞消息     - WebcastLinkMicFanTicketMethod: 连麦粉丝票方法     - WebcastLinkMicMethod: 连麦方法 ### 返回: - 弹幕数据的WebSocket连接信息，需要使用WebSocket连接获取弹幕数据，此接口不返回弹幕数据。  # [English] ### Purpose: - Extract live room danmaku #### Price: - 0.001$ per 10 data, support tiered billing discount. ### Parameters: - live_room_url: Live room link - danmaku_type: Message type     - WebcastChatMessage: Chat message     - WebcastMemberMessage: Member message     - WebcastRoomUserSeqMessage: User sequence message     - WebcastGiftMessage: Gift message     - WebcastSocialMessage: Social message     - WebcastLikeMessage: Like message     - WebcastLinkMicFanTicketMethod: Link Mic Fan Ticket Method     - WebcastLinkMicMethod: Link Mic Method ### Return: - WebSocket connection information of the danmaku data, you need to use WebSocket connection to get the danmaku data, this interface does not return the danmaku data.
  - @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param liveRoomUrl 直播间链接/Live room link
  - @param danmakuType 消息类型/Message type

@return ResponseModel
*/
func (a *TikTokWebAPIApiService) DouyinLiveRoomApiV1TiktokWebTiktokLiveRoomGet_1(ctx _context.Context, liveRoomUrl string, danmakuType string) (ResponseModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResponseModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/tiktok/web/tiktok_live_room"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	localVarQueryParams.Add("live_room_url", parameterToString(liveRoomUrl, ""))
	localVarQueryParams.Add("danmaku_type", parameterToString(danmakuType, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
FetchCheckLiveAliveApiV1TiktokWebFetchCheckLiveAliveGet 直播间开播状态检测/Live room start status check
# [中文] ### 用途: - 直播间开播状态检测 - 如果当前直播间不存在或已下播，则返回空。 ### 参数: - room_id: 直播间ID ### 返回: - 直播间开播状态  # [English] ### Purpose: - Live room start status check - If the current live room does not exist or has ended, it will return empty. ### Parameters: - room_id: Live room ID ### Return: - Live room start status  # [示例/Example] room_id &#x3D; \&quot;7381444193462078214\&quot;
  - @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param roomId 直播间ID/Live room ID

@return ResponseModel
*/
func (a *TikTokWebAPIApiService) FetchCheckLiveAliveApiV1TiktokWebFetchCheckLiveAliveGet(ctx _context.Context, roomId string) (ResponseModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResponseModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/tiktok/web/fetch_check_live_alive"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	localVarQueryParams.Add("room_id", parameterToString(roomId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
FetchCheckLiveAliveApiV1TiktokWebFetchCheckLiveAliveGet_0 直播间开播状态检测/Live room start status check
# [中文] ### 用途: - 直播间开播状态检测 - 如果当前直播间不存在或已下播，则返回空。 ### 参数: - room_id: 直播间ID ### 返回: - 直播间开播状态  # [English] ### Purpose: - Live room start status check - If the current live room does not exist or has ended, it will return empty. ### Parameters: - room_id: Live room ID ### Return: - Live room start status  # [示例/Example] room_id &#x3D; \&quot;7381444193462078214\&quot;
  - @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param roomId 直播间ID/Live room ID

@return ResponseModel
*/
func (a *TikTokWebAPIApiService) FetchCheckLiveAliveApiV1TiktokWebFetchCheckLiveAliveGet_2(ctx _context.Context, roomId string) (ResponseModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResponseModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/tiktok/web/fetch_check_live_alive"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	localVarQueryParams.Add("room_id", parameterToString(roomId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// TikTokWebAPIApiFetchExplorePostApiV1TiktokWebFetchExplorePostGetOpts Optional parameters for the method 'FetchExplorePostApiV1TiktokWebFetchExplorePostGet'
type TikTokWebAPIApiFetchExplorePostApiV1TiktokWebFetchExplorePostGetOpts struct {
	CategoryType optional.String
	Count        optional.Int32
}

/*
FetchExplorePostApiV1TiktokWebFetchExplorePostGet 获取探索作品数据/Get explore video data
# [中文] ### 用途: - 获取探索作品数据 ### 参数: - categoryType: 作品分类     - 100: 动画与漫画     - 101: 表演     - 102: 美容护理     - 103: 游戏     - 104: 喜剧     - 105: 日常生活     - 106: 家庭     - 107: 情感关系     - 108: 戏剧     - 109: 穿搭     - 110: 对口型     - 111: 美食     - 112: 运动     - 113: 动物     - 114: 社会     - 115: 汽车     - 116: 教育     - 117: 健身和健康     - 118: 科技     - 119: 唱歌跳舞     - 120: 全部 - count: 每页数量 ### 返回: - 作品数据  # [English] ### Purpose: - Get explore video data ### Parameters: - categoryType: Video category     - 100: Animation and comics     - 101: Performance     - 102: Beauty care     - 103: Game     - 104: Comedy     - 105: Daily life     - 106: Family     - 107: Emotional relationship     - 108: Drama     - 109: Dress up     - 110: Dubbing     - 111: Food     - 112: Sports     - 113: Animals     - 114: Society     - 115: Car     - 116: Education     - 117: Fitness and health     - 118: Technology     - 119: Singing and dancing     - 120: All - count: Number per page ### Return: - Video data  # [示例/Example] categoryType &#x3D; \&quot;120\&quot; count &#x3D; 16
  - @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param optional nil or *TikTokWebAPIApiFetchExplorePostApiV1TiktokWebFetchExplorePostGetOpts - Optional Parameters:
  - @param "CategoryType" (optional.String) -  作品分类/Video category
  - @param "Count" (optional.Int32) -  每页数量/Number per page

@return ResponseModel
*/
func (a *TikTokWebAPIApiService) FetchExplorePostApiV1TiktokWebFetchExplorePostGet(ctx _context.Context, localVarOptionals *TikTokWebAPIApiFetchExplorePostApiV1TiktokWebFetchExplorePostGetOpts) (ResponseModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResponseModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/tiktok/web/fetch_explore_post"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.CategoryType.IsSet() {
		localVarQueryParams.Add("categoryType", parameterToString(localVarOptionals.CategoryType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Count.IsSet() {
		localVarQueryParams.Add("count", parameterToString(localVarOptionals.Count.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// TikTokWebAPIApiFetchExplorePostApiV1TiktokWebFetchExplorePostGet_3Opts Optional parameters for the method 'FetchExplorePostApiV1TiktokWebFetchExplorePostGet_3'
type TikTokWebAPIApiFetchExplorePostApiV1TiktokWebFetchExplorePostGet_3Opts struct {
	CategoryType optional.String
	Count        optional.Int32
}

/*
FetchExplorePostApiV1TiktokWebFetchExplorePostGet_0 获取探索作品数据/Get explore video data
# [中文] ### 用途: - 获取探索作品数据 ### 参数: - categoryType: 作品分类     - 100: 动画与漫画     - 101: 表演     - 102: 美容护理     - 103: 游戏     - 104: 喜剧     - 105: 日常生活     - 106: 家庭     - 107: 情感关系     - 108: 戏剧     - 109: 穿搭     - 110: 对口型     - 111: 美食     - 112: 运动     - 113: 动物     - 114: 社会     - 115: 汽车     - 116: 教育     - 117: 健身和健康     - 118: 科技     - 119: 唱歌跳舞     - 120: 全部 - count: 每页数量 ### 返回: - 作品数据  # [English] ### Purpose: - Get explore video data ### Parameters: - categoryType: Video category     - 100: Animation and comics     - 101: Performance     - 102: Beauty care     - 103: Game     - 104: Comedy     - 105: Daily life     - 106: Family     - 107: Emotional relationship     - 108: Drama     - 109: Dress up     - 110: Dubbing     - 111: Food     - 112: Sports     - 113: Animals     - 114: Society     - 115: Car     - 116: Education     - 117: Fitness and health     - 118: Technology     - 119: Singing and dancing     - 120: All - count: Number per page ### Return: - Video data  # [示例/Example] categoryType &#x3D; \&quot;120\&quot; count &#x3D; 16
  - @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param optional nil or *TikTokWebAPIApiFetchExplorePostApiV1TiktokWebFetchExplorePostGet_3Opts - Optional Parameters:
  - @param "CategoryType" (optional.String) -  作品分类/Video category
  - @param "Count" (optional.Int32) -  每页数量/Number per page

@return ResponseModel
*/
func (a *TikTokWebAPIApiService) FetchExplorePostApiV1TiktokWebFetchExplorePostGet_3(ctx _context.Context, localVarOptionals *TikTokWebAPIApiFetchExplorePostApiV1TiktokWebFetchExplorePostGet_3Opts) (ResponseModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResponseModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/tiktok/web/fetch_explore_post"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.CategoryType.IsSet() {
		localVarQueryParams.Add("categoryType", parameterToString(localVarOptionals.CategoryType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Count.IsSet() {
		localVarQueryParams.Add("count", parameterToString(localVarOptionals.Count.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// TikTokWebAPIApiFetchGeneralSearchApiV1TiktokWebFetchGeneralSearchGetOpts Optional parameters for the method 'FetchGeneralSearchApiV1TiktokWebFetchGeneralSearchGet'
type TikTokWebAPIApiFetchGeneralSearchApiV1TiktokWebFetchGeneralSearchGetOpts struct {
	Offset   optional.Int32
	SearchId optional.String
	Cookie   optional.String
}

/*
FetchGeneralSearchApiV1TiktokWebFetchGeneralSearchGet 获取综合搜索列表/Get general search list
# [中文] ### 用途: - 获取综合搜索列表 ### 参数: - keyword: 搜索关键词 - offset: 翻页游标，第一次请求时为0，第二次请求时从上一次请求的返回响应中获取，一般这个值的关键字为offset或者cursor。 - search_id: 搜索id，第一次请求时为空，第二次翻页时需要提供，需要从上一次请求的返回响应中获取。     - 例如: search_id &#x3D; \&quot;20240828035554C02011379EBB6A00E00B\&quot;     - JSON Path-1 : $.data.extra.logid     - JSON Path-2 : $.data.log_pb.impr_id - cookie: 用户cookie(如果你需要使用自己的账号搜索，或者遇到接口报错，可以自行提供cookie，默认不需要提供) ### 返回: - 综合搜索列表  # [English] ### Purpose: - Get general search list ### Parameters: - keyword: Search keyword - offset: Page cursor, 0 for the first request, need to provide for the second paging, generally the keyword of this value is offset or cursor. - search_id: Search id, empty for the first request, need to provide for the second paging, need to get it from the return response of the last request.     - For example: search_id &#x3D; \&quot;20240828035554C02011379EBB6A00E00B\&quot;     - JSON Path-1 : $.data.extra.logid     - JSON Path-2 : $.data.log_pb.impr_id - cookie: User cookie (If you need to search with your own account, or encounter an interface error, you can provide the cookie yourself, default is not required) ### Return: - General search list  # [示例/Example] keyword &#x3D; \&quot;TikTok\&quot; offset &#x3D; 0 search_id &#x3D; \&quot;\&quot;
  - @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param keyword 搜索关键词/Search keyword
  - @param optional nil or *TikTokWebAPIApiFetchGeneralSearchApiV1TiktokWebFetchGeneralSearchGetOpts - Optional Parameters:
  - @param "Offset" (optional.Int32) -  翻页游标/Page cursor
  - @param "SearchId" (optional.String) -  搜索id，翻页时需要提供/Search id, need to provide when paging
  - @param "Cookie" (optional.String) -  用户cookie(按需提供)/User cookie(if needed)

@return ResponseModel
*/
func (a *TikTokWebAPIApiService) FetchGeneralSearchApiV1TiktokWebFetchGeneralSearchGet(ctx _context.Context, keyword string, localVarOptionals *TikTokWebAPIApiFetchGeneralSearchApiV1TiktokWebFetchGeneralSearchGetOpts) (ResponseModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResponseModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/tiktok/web/fetch_general_search"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	localVarQueryParams.Add("keyword", parameterToString(keyword, ""))
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SearchId.IsSet() {
		localVarQueryParams.Add("search_id", parameterToString(localVarOptionals.SearchId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Cookie.IsSet() {
		localVarQueryParams.Add("cookie", parameterToString(localVarOptionals.Cookie.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// TikTokWebAPIApiFetchGeneralSearchApiV1TiktokWebFetchGeneralSearchGet_4Opts Optional parameters for the method 'FetchGeneralSearchApiV1TiktokWebFetchGeneralSearchGet_4'
type TikTokWebAPIApiFetchGeneralSearchApiV1TiktokWebFetchGeneralSearchGet_4Opts struct {
	Offset   optional.Int32
	SearchId optional.String
	Cookie   optional.String
}

/*
FetchGeneralSearchApiV1TiktokWebFetchGeneralSearchGet_0 获取综合搜索列表/Get general search list
# [中文] ### 用途: - 获取综合搜索列表 ### 参数: - keyword: 搜索关键词 - offset: 翻页游标，第一次请求时为0，第二次请求时从上一次请求的返回响应中获取，一般这个值的关键字为offset或者cursor。 - search_id: 搜索id，第一次请求时为空，第二次翻页时需要提供，需要从上一次请求的返回响应中获取。     - 例如: search_id &#x3D; \&quot;20240828035554C02011379EBB6A00E00B\&quot;     - JSON Path-1 : $.data.extra.logid     - JSON Path-2 : $.data.log_pb.impr_id - cookie: 用户cookie(如果你需要使用自己的账号搜索，或者遇到接口报错，可以自行提供cookie，默认不需要提供) ### 返回: - 综合搜索列表  # [English] ### Purpose: - Get general search list ### Parameters: - keyword: Search keyword - offset: Page cursor, 0 for the first request, need to provide for the second paging, generally the keyword of this value is offset or cursor. - search_id: Search id, empty for the first request, need to provide for the second paging, need to get it from the return response of the last request.     - For example: search_id &#x3D; \&quot;20240828035554C02011379EBB6A00E00B\&quot;     - JSON Path-1 : $.data.extra.logid     - JSON Path-2 : $.data.log_pb.impr_id - cookie: User cookie (If you need to search with your own account, or encounter an interface error, you can provide the cookie yourself, default is not required) ### Return: - General search list  # [示例/Example] keyword &#x3D; \&quot;TikTok\&quot; offset &#x3D; 0 search_id &#x3D; \&quot;\&quot;
  - @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param keyword 搜索关键词/Search keyword
  - @param optional nil or *TikTokWebAPIApiFetchGeneralSearchApiV1TiktokWebFetchGeneralSearchGet_4Opts - Optional Parameters:
  - @param "Offset" (optional.Int32) -  翻页游标/Page cursor
  - @param "SearchId" (optional.String) -  搜索id，翻页时需要提供/Search id, need to provide when paging
  - @param "Cookie" (optional.String) -  用户cookie(按需提供)/User cookie(if needed)

@return ResponseModel
*/
func (a *TikTokWebAPIApiService) FetchGeneralSearchApiV1TiktokWebFetchGeneralSearchGet_4(ctx _context.Context, keyword string, localVarOptionals *TikTokWebAPIApiFetchGeneralSearchApiV1TiktokWebFetchGeneralSearchGet_4Opts) (ResponseModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResponseModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/tiktok/web/fetch_general_search"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	localVarQueryParams.Add("keyword", parameterToString(keyword, ""))
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SearchId.IsSet() {
		localVarQueryParams.Add("search_id", parameterToString(localVarOptionals.SearchId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Cookie.IsSet() {
		localVarQueryParams.Add("cookie", parameterToString(localVarOptionals.Cookie.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// TikTokWebAPIApiFetchHomeFeedApiV1TiktokWebFetchHomeFeedPostOpts Optional parameters for the method 'FetchHomeFeedApiV1TiktokWebFetchHomeFeedPost'
type TikTokWebAPIApiFetchHomeFeedApiV1TiktokWebFetchHomeFeedPostOpts struct {
	UNKNOWNBASETYPE optional.Interface
}

/*
FetchHomeFeedApiV1TiktokWebFetchHomeFeedPost 首页推荐作品/Home Feed
# [中文] ### 用途: - 首页推荐作品 ### 参数: - count: 每页数量 - cookie: 用户自己的cookie，可选参数，用于接口返回数据的个性化推荐。 ### 返回: - 首页推荐作品  # [English] ### Purpose: - Home Feed ### Parameters: - count: Number per page - cookie: User&#39;s own cookie, optional parameter, used for personalized recommendations of interface return data. ### Return: - Home Feed  # [示例/Example] count &#x3D; 15 Cookie &#x3D; \&quot;Your_Cookie\&quot;
  - @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param optional nil or *TikTokWebAPIApiFetchHomeFeedApiV1TiktokWebFetchHomeFeedPostOpts - Optional Parameters:
  - @param "UNKNOWNBASETYPE" (optional.Interface of UNKNOWN_BASE_TYPE) -

@return ResponseModel
*/
func (a *TikTokWebAPIApiService) FetchHomeFeedApiV1TiktokWebFetchHomeFeedPost(ctx _context.Context, localVarOptionals *TikTokWebAPIApiFetchHomeFeedApiV1TiktokWebFetchHomeFeedPostOpts) (ResponseModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResponseModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/tiktok/web/fetch_home_feed"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.UNKNOWNBASETYPE.IsSet() {
		localVarOptionalUNKNOWNBASETYPE, localVarOptionalUNKNOWNBASETYPEok := localVarOptionals.UNKNOWNBASETYPE.Value().(UNKNOWN_BASE_TYPE)
		if !localVarOptionalUNKNOWNBASETYPEok {
			return localVarReturnValue, nil, reportError("uNKNOWNBASETYPE should be UNKNOWN_BASE_TYPE")
		}
		localVarPostBody = &localVarOptionalUNKNOWNBASETYPE
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// TikTokWebAPIApiFetchHomeFeedApiV1TiktokWebFetchHomeFeedPost_5Opts Optional parameters for the method 'FetchHomeFeedApiV1TiktokWebFetchHomeFeedPost_5'
type TikTokWebAPIApiFetchHomeFeedApiV1TiktokWebFetchHomeFeedPost_5Opts struct {
	UNKNOWNBASETYPE optional.Interface
}

/*
FetchHomeFeedApiV1TiktokWebFetchHomeFeedPost_0 首页推荐作品/Home Feed
# [中文] ### 用途: - 首页推荐作品 ### 参数: - count: 每页数量 - cookie: 用户自己的cookie，可选参数，用于接口返回数据的个性化推荐。 ### 返回: - 首页推荐作品  # [English] ### Purpose: - Home Feed ### Parameters: - count: Number per page - cookie: User&#39;s own cookie, optional parameter, used for personalized recommendations of interface return data. ### Return: - Home Feed  # [示例/Example] count &#x3D; 15 Cookie &#x3D; \&quot;Your_Cookie\&quot;
  - @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param optional nil or *TikTokWebAPIApiFetchHomeFeedApiV1TiktokWebFetchHomeFeedPost_5Opts - Optional Parameters:
  - @param "UNKNOWNBASETYPE" (optional.Interface of UNKNOWN_BASE_TYPE) -

@return ResponseModel
*/
func (a *TikTokWebAPIApiService) FetchHomeFeedApiV1TiktokWebFetchHomeFeedPost_5(ctx _context.Context, localVarOptionals *TikTokWebAPIApiFetchHomeFeedApiV1TiktokWebFetchHomeFeedPost_5Opts) (ResponseModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResponseModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/tiktok/web/fetch_home_feed"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.UNKNOWNBASETYPE.IsSet() {
		localVarOptionalUNKNOWNBASETYPE, localVarOptionalUNKNOWNBASETYPEok := localVarOptionals.UNKNOWNBASETYPE.Value().(UNKNOWN_BASE_TYPE)
		if !localVarOptionalUNKNOWNBASETYPEok {
			return localVarReturnValue, nil, reportError("uNKNOWNBASETYPE should be UNKNOWN_BASE_TYPE")
		}
		localVarPostBody = &localVarOptionalUNKNOWNBASETYPE
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
FetchLiveRecommendApiV1TiktokWebFetchLiveRecommendGet 获取直播间首页推荐列表/Get live room homepage recommendation list
# [中文] ### 用途: - 获取直播间首页推荐列表 ### 参数: - related_live_tag: 相关直播标签 ### 返回: - 直播间首页推荐列表  # [English] ### Purpose: - Get live room homepage recommendation list ### Parameters: - related_live_tag: Related live tag ### Return: - Live room homepage recommendation list  # [示例/Example] related_live_tag &#x3D; \&quot;VALORANT\&quot;
  - @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param relatedLiveTag 相关直播标签/Related live tag

@return ResponseModel
*/
func (a *TikTokWebAPIApiService) FetchLiveRecommendApiV1TiktokWebFetchLiveRecommendGet(ctx _context.Context, relatedLiveTag string) (ResponseModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResponseModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/tiktok/web/fetch_live_recommend"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	localVarQueryParams.Add("related_live_tag", parameterToString(relatedLiveTag, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
FetchLiveRecommendApiV1TiktokWebFetchLiveRecommendGet_0 获取直播间首页推荐列表/Get live room homepage recommendation list
# [中文] ### 用途: - 获取直播间首页推荐列表 ### 参数: - related_live_tag: 相关直播标签 ### 返回: - 直播间首页推荐列表  # [English] ### Purpose: - Get live room homepage recommendation list ### Parameters: - related_live_tag: Related live tag ### Return: - Live room homepage recommendation list  # [示例/Example] related_live_tag &#x3D; \&quot;VALORANT\&quot;
  - @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param relatedLiveTag 相关直播标签/Related live tag

@return ResponseModel
*/
func (a *TikTokWebAPIApiService) FetchLiveRecommendApiV1TiktokWebFetchLiveRecommendGet_6(ctx _context.Context, relatedLiveTag string) (ResponseModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResponseModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/tiktok/web/fetch_live_recommend"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	localVarQueryParams.Add("related_live_tag", parameterToString(relatedLiveTag, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// TikTokWebAPIApiFetchPostCommentApiV1TiktokWebFetchPostCommentGetOpts Optional parameters for the method 'FetchPostCommentApiV1TiktokWebFetchPostCommentGet'
type TikTokWebAPIApiFetchPostCommentApiV1TiktokWebFetchPostCommentGetOpts struct {
	Cursor        optional.Int32
	Count         optional.Int32
	CurrentRegion optional.String
}

/*
FetchPostCommentApiV1TiktokWebFetchPostCommentGet 获取作品的评论列表/Get video comments
# [中文] ### 用途: - 获取作品的评论列表 ### 参数: - aweme_id: 作品id - cursor: 翻页游标 - count: 每页数量 - current_region: 当前地区，默认为空。 ### 返回: - 作品的评论列表  # [English] ### Purpose: - Get video comments ### Parameters: - aweme_id: Video id - cursor: Page cursor - count: Number per page - current_region: Current region, default is empty. ### Return: - Video comments  # [示例/Eample] aweme_id &#x3D; \&quot;7304809083817774382\&quot; cursor &#x3D; 0 count &#x3D; 20 current_region &#x3D; \&quot;\&quot;
  - @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param awemeId 作品id/Video id
  - @param optional nil or *TikTokWebAPIApiFetchPostCommentApiV1TiktokWebFetchPostCommentGetOpts - Optional Parameters:
  - @param "Cursor" (optional.Int32) -  翻页游标/Page cursor
  - @param "Count" (optional.Int32) -  每页数量/Number per page
  - @param "CurrentRegion" (optional.String) -  当前地区/Current region

@return ResponseModel
*/
func (a *TikTokWebAPIApiService) FetchPostCommentApiV1TiktokWebFetchPostCommentGet(ctx _context.Context, awemeId string, localVarOptionals *TikTokWebAPIApiFetchPostCommentApiV1TiktokWebFetchPostCommentGetOpts) (ResponseModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResponseModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/tiktok/web/fetch_post_comment"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	localVarQueryParams.Add("aweme_id", parameterToString(awemeId, ""))
	if localVarOptionals != nil && localVarOptionals.Cursor.IsSet() {
		localVarQueryParams.Add("cursor", parameterToString(localVarOptionals.Cursor.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Count.IsSet() {
		localVarQueryParams.Add("count", parameterToString(localVarOptionals.Count.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CurrentRegion.IsSet() {
		localVarQueryParams.Add("current_region", parameterToString(localVarOptionals.CurrentRegion.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// TikTokWebAPIApiFetchPostCommentApiV1TiktokWebFetchPostCommentGet_7Opts Optional parameters for the method 'FetchPostCommentApiV1TiktokWebFetchPostCommentGet_7'
type TikTokWebAPIApiFetchPostCommentApiV1TiktokWebFetchPostCommentGet_7Opts struct {
	Cursor        optional.Int32
	Count         optional.Int32
	CurrentRegion optional.String
}

/*
FetchPostCommentApiV1TiktokWebFetchPostCommentGet_0 获取作品的评论列表/Get video comments
# [中文] ### 用途: - 获取作品的评论列表 ### 参数: - aweme_id: 作品id - cursor: 翻页游标 - count: 每页数量 - current_region: 当前地区，默认为空。 ### 返回: - 作品的评论列表  # [English] ### Purpose: - Get video comments ### Parameters: - aweme_id: Video id - cursor: Page cursor - count: Number per page - current_region: Current region, default is empty. ### Return: - Video comments  # [示例/Eample] aweme_id &#x3D; \&quot;7304809083817774382\&quot; cursor &#x3D; 0 count &#x3D; 20 current_region &#x3D; \&quot;\&quot;
  - @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param awemeId 作品id/Video id
  - @param optional nil or *TikTokWebAPIApiFetchPostCommentApiV1TiktokWebFetchPostCommentGet_7Opts - Optional Parameters:
  - @param "Cursor" (optional.Int32) -  翻页游标/Page cursor
  - @param "Count" (optional.Int32) -  每页数量/Number per page
  - @param "CurrentRegion" (optional.String) -  当前地区/Current region

@return ResponseModel
*/
func (a *TikTokWebAPIApiService) FetchPostCommentApiV1TiktokWebFetchPostCommentGet_7(ctx _context.Context, awemeId string, localVarOptionals *TikTokWebAPIApiFetchPostCommentApiV1TiktokWebFetchPostCommentGet_7Opts) (ResponseModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResponseModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/tiktok/web/fetch_post_comment"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	localVarQueryParams.Add("aweme_id", parameterToString(awemeId, ""))
	if localVarOptionals != nil && localVarOptionals.Cursor.IsSet() {
		localVarQueryParams.Add("cursor", parameterToString(localVarOptionals.Cursor.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Count.IsSet() {
		localVarQueryParams.Add("count", parameterToString(localVarOptionals.Count.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CurrentRegion.IsSet() {
		localVarQueryParams.Add("current_region", parameterToString(localVarOptionals.CurrentRegion.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// TikTokWebAPIApiFetchPostCommentReplyApiV1TiktokWebFetchPostCommentReplyGetOpts Optional parameters for the method 'FetchPostCommentReplyApiV1TiktokWebFetchPostCommentReplyGet'
type TikTokWebAPIApiFetchPostCommentReplyApiV1TiktokWebFetchPostCommentReplyGetOpts struct {
	Cursor        optional.Int32
	Count         optional.Int32
	CurrentRegion optional.String
}

/*
FetchPostCommentReplyApiV1TiktokWebFetchPostCommentReplyGet 获取作品的评论回复列表/Get video comment replies
# [中文] ### 用途: - 获取作品的评论回复列表 ### 参数: - item_id: 作品id - comment_id: 评论id - cursor: 翻页游标 - count: 每页数量 - current_region: 当前地区，默认为空。 ### 返回: - 作品的评论回复列表  # [English] ### Purpose: - Get video comment replies ### Parameters: - item_id: Video id - comment_id: Comment id - cursor: Page cursor - count: Number per page - current_region: Current region, default is empty. ### Return: - Video comment replies  # [示例/Eample] item_id &#x3D; \&quot;7304809083817774382\&quot; comment_id &#x3D; \&quot;7304877760886588191\&quot; cursor &#x3D; 0 count &#x3D; 20 current_region &#x3D; \&quot;\&quot;
  - @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param itemId 作品id/Video id
  - @param commentId 评论id/Comment id
  - @param optional nil or *TikTokWebAPIApiFetchPostCommentReplyApiV1TiktokWebFetchPostCommentReplyGetOpts - Optional Parameters:
  - @param "Cursor" (optional.Int32) -  翻页游标/Page cursor
  - @param "Count" (optional.Int32) -  每页数量/Number per page
  - @param "CurrentRegion" (optional.String) -  当前地区/Current region

@return ResponseModel
*/
func (a *TikTokWebAPIApiService) FetchPostCommentReplyApiV1TiktokWebFetchPostCommentReplyGet(ctx _context.Context, itemId string, commentId string, localVarOptionals *TikTokWebAPIApiFetchPostCommentReplyApiV1TiktokWebFetchPostCommentReplyGetOpts) (ResponseModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResponseModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/tiktok/web/fetch_post_comment_reply"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	localVarQueryParams.Add("item_id", parameterToString(itemId, ""))
	localVarQueryParams.Add("comment_id", parameterToString(commentId, ""))
	if localVarOptionals != nil && localVarOptionals.Cursor.IsSet() {
		localVarQueryParams.Add("cursor", parameterToString(localVarOptionals.Cursor.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Count.IsSet() {
		localVarQueryParams.Add("count", parameterToString(localVarOptionals.Count.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CurrentRegion.IsSet() {
		localVarQueryParams.Add("current_region", parameterToString(localVarOptionals.CurrentRegion.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// TikTokWebAPIApiFetchPostCommentReplyApiV1TiktokWebFetchPostCommentReplyGet_8Opts Optional parameters for the method 'FetchPostCommentReplyApiV1TiktokWebFetchPostCommentReplyGet_8'
type TikTokWebAPIApiFetchPostCommentReplyApiV1TiktokWebFetchPostCommentReplyGet_8Opts struct {
	Cursor        optional.Int32
	Count         optional.Int32
	CurrentRegion optional.String
}

/*
FetchPostCommentReplyApiV1TiktokWebFetchPostCommentReplyGet_0 获取作品的评论回复列表/Get video comment replies
# [中文] ### 用途: - 获取作品的评论回复列表 ### 参数: - item_id: 作品id - comment_id: 评论id - cursor: 翻页游标 - count: 每页数量 - current_region: 当前地区，默认为空。 ### 返回: - 作品的评论回复列表  # [English] ### Purpose: - Get video comment replies ### Parameters: - item_id: Video id - comment_id: Comment id - cursor: Page cursor - count: Number per page - current_region: Current region, default is empty. ### Return: - Video comment replies  # [示例/Eample] item_id &#x3D; \&quot;7304809083817774382\&quot; comment_id &#x3D; \&quot;7304877760886588191\&quot; cursor &#x3D; 0 count &#x3D; 20 current_region &#x3D; \&quot;\&quot;
  - @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param itemId 作品id/Video id
  - @param commentId 评论id/Comment id
  - @param optional nil or *TikTokWebAPIApiFetchPostCommentReplyApiV1TiktokWebFetchPostCommentReplyGet_8Opts - Optional Parameters:
  - @param "Cursor" (optional.Int32) -  翻页游标/Page cursor
  - @param "Count" (optional.Int32) -  每页数量/Number per page
  - @param "CurrentRegion" (optional.String) -  当前地区/Current region

@return ResponseModel
*/
func (a *TikTokWebAPIApiService) FetchPostCommentReplyApiV1TiktokWebFetchPostCommentReplyGet_8(ctx _context.Context, itemId string, commentId string, localVarOptionals *TikTokWebAPIApiFetchPostCommentReplyApiV1TiktokWebFetchPostCommentReplyGet_8Opts) (ResponseModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResponseModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/tiktok/web/fetch_post_comment_reply"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	localVarQueryParams.Add("item_id", parameterToString(itemId, ""))
	localVarQueryParams.Add("comment_id", parameterToString(commentId, ""))
	if localVarOptionals != nil && localVarOptionals.Cursor.IsSet() {
		localVarQueryParams.Add("cursor", parameterToString(localVarOptionals.Cursor.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Count.IsSet() {
		localVarQueryParams.Add("count", parameterToString(localVarOptionals.Count.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CurrentRegion.IsSet() {
		localVarQueryParams.Add("current_region", parameterToString(localVarOptionals.CurrentRegion.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
FetchPostDetailApiV1TiktokWebFetchPostDetailGet 获取单个作品数据/Get single video data
# [中文] ### 用途: - 获取单个作品数据 - 此接口无法用于视频下载，只能获取视频数据，访问此接口返回的视频链接会返回HTTP403报错。 - 如果有视频下载需求，请使用 /api/v1/tiktok/app/v2/fetch_one_video 接口。 ### 参数: - itemId: 作品id ### 返回: - 作品数据  # [English] ### Purpose: - Get single video data - This interface cannot be used for video download, it can only get video data, and accessing the video link returned by this interface will return an HTTP403 error. - If you need to download videos, please use the /api/v1/tiktok/app/v2/fetch_one_video interface. ### Parameters: - itemId: Video id ### Return: - Video data  # [示例/Example] itemId &#x3D; \&quot;7339393672959757570\&quot;
  - @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param itemId 作品id/Video id

@return ResponseModel
*/
func (a *TikTokWebAPIApiService) FetchPostDetailApiV1TiktokWebFetchPostDetailGet(ctx _context.Context, itemId string) (ResponseModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResponseModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/tiktok/web/fetch_post_detail"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	localVarQueryParams.Add("itemId", parameterToString(itemId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
FetchPostDetailApiV1TiktokWebFetchPostDetailGet_0 获取单个作品数据/Get single video data
# [中文] ### 用途: - 获取单个作品数据 - 此接口无法用于视频下载，只能获取视频数据，访问此接口返回的视频链接会返回HTTP403报错。 - 如果有视频下载需求，请使用 /api/v1/tiktok/app/v2/fetch_one_video 接口。 ### 参数: - itemId: 作品id ### 返回: - 作品数据  # [English] ### Purpose: - Get single video data - This interface cannot be used for video download, it can only get video data, and accessing the video link returned by this interface will return an HTTP403 error. - If you need to download videos, please use the /api/v1/tiktok/app/v2/fetch_one_video interface. ### Parameters: - itemId: Video id ### Return: - Video data  # [示例/Example] itemId &#x3D; \&quot;7339393672959757570\&quot;
  - @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param itemId 作品id/Video id

@return ResponseModel
*/
func (a *TikTokWebAPIApiService) FetchPostDetailApiV1TiktokWebFetchPostDetailGet_9(ctx _context.Context, itemId string) (ResponseModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResponseModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/tiktok/web/fetch_post_detail"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	localVarQueryParams.Add("itemId", parameterToString(itemId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
FetchSearchKeywordSuggestApiV1TiktokWebFetchSearchKeywordSuggestGet 搜索关键字推荐/Search keyword suggest
# [中文] ### 用途: - 搜索关键字推荐 ### 参数: - keyword: 搜索关键词 ### 返回: - 关键字推荐列表  # [English] ### Purpose: - Search keyword suggest ### Parameters: - keyword: Search keyword ### Return: - Keyword suggest list  # [示例/Example] keyword &#x3D; \&quot;TikTok\&quot;
  - @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param keyword 搜索关键词/Search keyword

@return ResponseModel
*/
func (a *TikTokWebAPIApiService) FetchSearchKeywordSuggestApiV1TiktokWebFetchSearchKeywordSuggestGet(ctx _context.Context, keyword string) (ResponseModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResponseModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/tiktok/web/fetch_search_keyword_suggest"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	localVarQueryParams.Add("keyword", parameterToString(keyword, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
FetchSearchKeywordSuggestApiV1TiktokWebFetchSearchKeywordSuggestGet_0 搜索关键字推荐/Search keyword suggest
# [中文] ### 用途: - 搜索关键字推荐 ### 参数: - keyword: 搜索关键词 ### 返回: - 关键字推荐列表  # [English] ### Purpose: - Search keyword suggest ### Parameters: - keyword: Search keyword ### Return: - Keyword suggest list  # [示例/Example] keyword &#x3D; \&quot;TikTok\&quot;
  - @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param keyword 搜索关键词/Search keyword

@return ResponseModel
*/
func (a *TikTokWebAPIApiService) FetchSearchKeywordSuggestApiV1TiktokWebFetchSearchKeywordSuggestGet_10(ctx _context.Context, keyword string) (ResponseModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResponseModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/tiktok/web/fetch_search_keyword_suggest"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	localVarQueryParams.Add("keyword", parameterToString(keyword, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// TikTokWebAPIApiFetchSearchLiveApiV1TiktokWebFetchSearchLiveGetOpts Optional parameters for the method 'FetchSearchLiveApiV1TiktokWebFetchSearchLiveGet'
type TikTokWebAPIApiFetchSearchLiveApiV1TiktokWebFetchSearchLiveGetOpts struct {
	Count    optional.Int32
	Offset   optional.Int32
	SearchId optional.String
	Cookie   optional.String
}

/*
FetchSearchLiveApiV1TiktokWebFetchSearchLiveGet 搜索直播/Search live
# [中文] ### 用途: - 搜索直播 ### 参数: - keyword: 搜索关键词 - count: 每页数量 - offset: 翻页游标，第一次请求时为0，第二次请求时从上一次请求的返回响应中获取，一般这个值的关键字为offset或者cursor。 - search_id: 搜索id，第一次请求时为空，第二次翻页时需要提供，需要从上一次请求的返回响应中获取。     - 例如: search_id &#x3D; \&quot;20240828035554C02011379EBB6A00E00B\&quot;     - JSON Path-1 : $.data.extra.logid     - JSON Path-2 : $.data.log_pb.impr_id - cookie: 用户cookie(如果你需要使用自己的账号搜索，或者遇到接口报错，可以自行提供cookie，默认不需要提供) ### 返回: - 直播列表  # [English] ### Purpose: - Search live ### Parameters: - keyword: Search keyword - count: Number per page - offset: Page cursor, 0 for the first request, need to provide for the second paging, generally the keyword of this value is offset or cursor. - search_id: Search id, empty for the first request, need to provide for the second paging, need to get it from the return response of the last request.     - For example: search_id &#x3D; \&quot;20240828035554C02011379EBB6A00E00B\&quot;     - JSON Path-1 : $.data.extra.logid     - JSON Path-2 : $.data.log_pb.impr_id - cookie: User cookie (If you need to search with your own account, or encounter an interface error, you can provide the cookie yourself, default is not required) ### Return: - Live list  # [示例/Example] keyword &#x3D; \&quot;TikTok\&quot; count &#x3D; 20 offset &#x3D; 0 search_id &#x3D; \&quot;\&quot;
  - @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param keyword 搜索关键词/Search keyword
  - @param optional nil or *TikTokWebAPIApiFetchSearchLiveApiV1TiktokWebFetchSearchLiveGetOpts - Optional Parameters:
  - @param "Count" (optional.Int32) -  每页数量/Number per page
  - @param "Offset" (optional.Int32) -  翻页游标/Page cursor
  - @param "SearchId" (optional.String) -  搜索id，翻页时需要提供/Search id, need to provide when paging
  - @param "Cookie" (optional.String) -  用户cookie(按需提供)/User cookie(if needed)

@return ResponseModel
*/
func (a *TikTokWebAPIApiService) FetchSearchLiveApiV1TiktokWebFetchSearchLiveGet(ctx _context.Context, keyword string, localVarOptionals *TikTokWebAPIApiFetchSearchLiveApiV1TiktokWebFetchSearchLiveGetOpts) (ResponseModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResponseModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/tiktok/web/fetch_search_live"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	localVarQueryParams.Add("keyword", parameterToString(keyword, ""))
	if localVarOptionals != nil && localVarOptionals.Count.IsSet() {
		localVarQueryParams.Add("count", parameterToString(localVarOptionals.Count.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SearchId.IsSet() {
		localVarQueryParams.Add("search_id", parameterToString(localVarOptionals.SearchId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Cookie.IsSet() {
		localVarQueryParams.Add("cookie", parameterToString(localVarOptionals.Cookie.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// TikTokWebAPIApiFetchSearchLiveApiV1TiktokWebFetchSearchLiveGet_11Opts Optional parameters for the method 'FetchSearchLiveApiV1TiktokWebFetchSearchLiveGet_11'
type TikTokWebAPIApiFetchSearchLiveApiV1TiktokWebFetchSearchLiveGet_11Opts struct {
	Count    optional.Int32
	Offset   optional.Int32
	SearchId optional.String
	Cookie   optional.String
}

/*
FetchSearchLiveApiV1TiktokWebFetchSearchLiveGet_0 搜索直播/Search live
# [中文] ### 用途: - 搜索直播 ### 参数: - keyword: 搜索关键词 - count: 每页数量 - offset: 翻页游标，第一次请求时为0，第二次请求时从上一次请求的返回响应中获取，一般这个值的关键字为offset或者cursor。 - search_id: 搜索id，第一次请求时为空，第二次翻页时需要提供，需要从上一次请求的返回响应中获取。     - 例如: search_id &#x3D; \&quot;20240828035554C02011379EBB6A00E00B\&quot;     - JSON Path-1 : $.data.extra.logid     - JSON Path-2 : $.data.log_pb.impr_id - cookie: 用户cookie(如果你需要使用自己的账号搜索，或者遇到接口报错，可以自行提供cookie，默认不需要提供) ### 返回: - 直播列表  # [English] ### Purpose: - Search live ### Parameters: - keyword: Search keyword - count: Number per page - offset: Page cursor, 0 for the first request, need to provide for the second paging, generally the keyword of this value is offset or cursor. - search_id: Search id, empty for the first request, need to provide for the second paging, need to get it from the return response of the last request.     - For example: search_id &#x3D; \&quot;20240828035554C02011379EBB6A00E00B\&quot;     - JSON Path-1 : $.data.extra.logid     - JSON Path-2 : $.data.log_pb.impr_id - cookie: User cookie (If you need to search with your own account, or encounter an interface error, you can provide the cookie yourself, default is not required) ### Return: - Live list  # [示例/Example] keyword &#x3D; \&quot;TikTok\&quot; count &#x3D; 20 offset &#x3D; 0 search_id &#x3D; \&quot;\&quot;
  - @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param keyword 搜索关键词/Search keyword
  - @param optional nil or *TikTokWebAPIApiFetchSearchLiveApiV1TiktokWebFetchSearchLiveGet_11Opts - Optional Parameters:
  - @param "Count" (optional.Int32) -  每页数量/Number per page
  - @param "Offset" (optional.Int32) -  翻页游标/Page cursor
  - @param "SearchId" (optional.String) -  搜索id，翻页时需要提供/Search id, need to provide when paging
  - @param "Cookie" (optional.String) -  用户cookie(按需提供)/User cookie(if needed)

@return ResponseModel
*/
func (a *TikTokWebAPIApiService) FetchSearchLiveApiV1TiktokWebFetchSearchLiveGet_11(ctx _context.Context, keyword string, localVarOptionals *TikTokWebAPIApiFetchSearchLiveApiV1TiktokWebFetchSearchLiveGet_11Opts) (ResponseModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResponseModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/tiktok/web/fetch_search_live"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	localVarQueryParams.Add("keyword", parameterToString(keyword, ""))
	if localVarOptionals != nil && localVarOptionals.Count.IsSet() {
		localVarQueryParams.Add("count", parameterToString(localVarOptionals.Count.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SearchId.IsSet() {
		localVarQueryParams.Add("search_id", parameterToString(localVarOptionals.SearchId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Cookie.IsSet() {
		localVarQueryParams.Add("cookie", parameterToString(localVarOptionals.Cookie.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// TikTokWebAPIApiFetchSearchUserApiV1TiktokWebFetchSearchUserGetOpts Optional parameters for the method 'FetchSearchUserApiV1TiktokWebFetchSearchUserGet'
type TikTokWebAPIApiFetchSearchUserApiV1TiktokWebFetchSearchUserGetOpts struct {
	Cursor   optional.Int32
	SearchId optional.String
	Cookie   optional.String
}

/*
FetchSearchUserApiV1TiktokWebFetchSearchUserGet 搜索用户/Search user
# [中文] ### 用途: - 搜索用户 ### 参数: - keyword: 搜索关键词 - cursor: 翻页游标，第一次请求时为0，第二次请求时从上一次请求的返回响应中获取，一般这个值的关键字为offset或者cursor。 - search_id: 搜索id，第一次请求时为空，第二次翻页时需要提供，需要从上一次请求的返回响应中获取。     - 例如: search_id &#x3D; \&quot;20240828035554C02011379EBB6A00E00B\&quot;     - JSON Path-1 : $.data.extra.logid     - JSON Path-2 : $.data.log_pb.impr_id - cookie: 用户cookie(如果你需要使用自己的账号搜索，或者遇到接口报错，可以自行提供cookie，默认不需要提供) ### 返回: - 用户列表  # [English] ### Purpose: - Search user ### Parameters: - keyword: Search keyword - cursor: Page cursor, 0 for the first request, need to provide for the second paging, generally the keyword of this value is offset or cursor. - search_id: Search id, empty for the first request, need to provide for the second paging, need to get it from the return response of the last request.     - For example: search_id &#x3D; \&quot;20240828035554C02011379EBB6A00E00B\&quot;     - JSON Path-1 : $.data.extra.logid     - JSON Path-2 : $.data.log_pb.impr_id - cookie: User cookie (If you need to search with your own account, or encounter an interface error, you can provide the cookie yourself, default is not required) ### Return: - User list  # [示例/Example] keyword &#x3D; \&quot;TikTok\&quot; cursor &#x3D; 0 search_id &#x3D; \&quot;\&quot;
  - @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param keyword 搜索关键词/Search keyword
  - @param optional nil or *TikTokWebAPIApiFetchSearchUserApiV1TiktokWebFetchSearchUserGetOpts - Optional Parameters:
  - @param "Cursor" (optional.Int32) -  翻页游标/Page cursor
  - @param "SearchId" (optional.String) -  搜索id，翻页时需要提供/Search id, need to provide when paging
  - @param "Cookie" (optional.String) -  用户cookie(按需提供)/User cookie(if needed)

@return ResponseModel
*/
func (a *TikTokWebAPIApiService) FetchSearchUserApiV1TiktokWebFetchSearchUserGet(ctx _context.Context, keyword string, localVarOptionals *TikTokWebAPIApiFetchSearchUserApiV1TiktokWebFetchSearchUserGetOpts) (ResponseModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResponseModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/tiktok/web/fetch_search_user"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	localVarQueryParams.Add("keyword", parameterToString(keyword, ""))
	if localVarOptionals != nil && localVarOptionals.Cursor.IsSet() {
		localVarQueryParams.Add("cursor", parameterToString(localVarOptionals.Cursor.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SearchId.IsSet() {
		localVarQueryParams.Add("search_id", parameterToString(localVarOptionals.SearchId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Cookie.IsSet() {
		localVarQueryParams.Add("cookie", parameterToString(localVarOptionals.Cookie.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// TikTokWebAPIApiFetchSearchUserApiV1TiktokWebFetchSearchUserGet_12Opts Optional parameters for the method 'FetchSearchUserApiV1TiktokWebFetchSearchUserGet_12'
type TikTokWebAPIApiFetchSearchUserApiV1TiktokWebFetchSearchUserGet_12Opts struct {
	Cursor   optional.Int32
	SearchId optional.String
	Cookie   optional.String
}

/*
FetchSearchUserApiV1TiktokWebFetchSearchUserGet_0 搜索用户/Search user
# [中文] ### 用途: - 搜索用户 ### 参数: - keyword: 搜索关键词 - cursor: 翻页游标，第一次请求时为0，第二次请求时从上一次请求的返回响应中获取，一般这个值的关键字为offset或者cursor。 - search_id: 搜索id，第一次请求时为空，第二次翻页时需要提供，需要从上一次请求的返回响应中获取。     - 例如: search_id &#x3D; \&quot;20240828035554C02011379EBB6A00E00B\&quot;     - JSON Path-1 : $.data.extra.logid     - JSON Path-2 : $.data.log_pb.impr_id - cookie: 用户cookie(如果你需要使用自己的账号搜索，或者遇到接口报错，可以自行提供cookie，默认不需要提供) ### 返回: - 用户列表  # [English] ### Purpose: - Search user ### Parameters: - keyword: Search keyword - cursor: Page cursor, 0 for the first request, need to provide for the second paging, generally the keyword of this value is offset or cursor. - search_id: Search id, empty for the first request, need to provide for the second paging, need to get it from the return response of the last request.     - For example: search_id &#x3D; \&quot;20240828035554C02011379EBB6A00E00B\&quot;     - JSON Path-1 : $.data.extra.logid     - JSON Path-2 : $.data.log_pb.impr_id - cookie: User cookie (If you need to search with your own account, or encounter an interface error, you can provide the cookie yourself, default is not required) ### Return: - User list  # [示例/Example] keyword &#x3D; \&quot;TikTok\&quot; cursor &#x3D; 0 search_id &#x3D; \&quot;\&quot;
  - @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param keyword 搜索关键词/Search keyword
  - @param optional nil or *TikTokWebAPIApiFetchSearchUserApiV1TiktokWebFetchSearchUserGet_12Opts - Optional Parameters:
  - @param "Cursor" (optional.Int32) -  翻页游标/Page cursor
  - @param "SearchId" (optional.String) -  搜索id，翻页时需要提供/Search id, need to provide when paging
  - @param "Cookie" (optional.String) -  用户cookie(按需提供)/User cookie(if needed)

@return ResponseModel
*/
func (a *TikTokWebAPIApiService) FetchSearchUserApiV1TiktokWebFetchSearchUserGet_12(ctx _context.Context, keyword string, localVarOptionals *TikTokWebAPIApiFetchSearchUserApiV1TiktokWebFetchSearchUserGet_12Opts) (ResponseModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResponseModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/tiktok/web/fetch_search_user"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	localVarQueryParams.Add("keyword", parameterToString(keyword, ""))
	if localVarOptionals != nil && localVarOptionals.Cursor.IsSet() {
		localVarQueryParams.Add("cursor", parameterToString(localVarOptionals.Cursor.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SearchId.IsSet() {
		localVarQueryParams.Add("search_id", parameterToString(localVarOptionals.SearchId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Cookie.IsSet() {
		localVarQueryParams.Add("cookie", parameterToString(localVarOptionals.Cookie.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// TikTokWebAPIApiFetchSearchVideoApiV1TiktokWebFetchSearchVideoGetOpts Optional parameters for the method 'FetchSearchVideoApiV1TiktokWebFetchSearchVideoGet'
type TikTokWebAPIApiFetchSearchVideoApiV1TiktokWebFetchSearchVideoGetOpts struct {
	Count    optional.Int32
	Offset   optional.Int32
	SearchId optional.String
	Cookie   optional.String
}

/*
FetchSearchVideoApiV1TiktokWebFetchSearchVideoGet 搜索视频/Search video
# [中文] ### 用途: - 搜索视频 ### 参数: - keyword: 搜索关键词 - count: 每页数量，建议保持默认值20。 - cursor: 翻页游标，第一次请求时为0，第二次请求时从上一次请求的返回响应中获取，一般这个值的关键字为offset或者cursor。 - search_id: 搜索id，第一次请求时为空，第二次翻页时需要提供，需要从上一次请求的返回响应中获取。     - 例如: search_id &#x3D; \&quot;20240828035554C02011379EBB6A00E00B\&quot;     - JSON Path-1 : $.data.extra.logid     - JSON Path-2 : $.data.log_pb.impr_id - cookie: 用户cookie(如果你需要使用自己的账号搜索，或者遇到接口报错，可以自行提供cookie，默认不需要提供) ### 返回: - 视频列表  # [English] ### Purpose: - Search video ### Parameters: - keyword: Search keyword - count: Number per page, it is recommended to keep the default value 20. - cursor: Page cursor, 0 for the first request, need to provide for the second paging, generally the keyword of this value is offset or cursor. - search_id: Search id, empty for the first request, need to provide for the second paging, need to get it from the return response of the last request.     - For example: search_id &#x3D; \&quot;20240828035554C02011379EBB6A00E00B\&quot;     - JSON Path-1 : $.data.extra.logid     - JSON Path-2 : $.data.log_pb.impr_id - offset: Page cursor - cookie: User cookie (If you need to search with your own account, or encounter an interface error, you can provide the cookie yourself, default is not required) ### Return: - Video list  # [示例/Example] keyword &#x3D; \&quot;TikTok\&quot; count &#x3D; 20 offset &#x3D; 0 search_id &#x3D; \&quot;\&quot;
  - @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param keyword 搜索关键词/Search keyword
  - @param optional nil or *TikTokWebAPIApiFetchSearchVideoApiV1TiktokWebFetchSearchVideoGetOpts - Optional Parameters:
  - @param "Count" (optional.Int32) -  每页数量/Number per page
  - @param "Offset" (optional.Int32) -  翻页游标/Page cursor
  - @param "SearchId" (optional.String) -  搜索id，翻页时需要提供/Search id, need to provide when paging
  - @param "Cookie" (optional.String) -  用户cookie(按需提供)/User cookie(if needed)

@return ResponseModel
*/
func (a *TikTokWebAPIApiService) FetchSearchVideoApiV1TiktokWebFetchSearchVideoGet(ctx _context.Context, keyword string, localVarOptionals *TikTokWebAPIApiFetchSearchVideoApiV1TiktokWebFetchSearchVideoGetOpts) (ResponseModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResponseModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/tiktok/web/fetch_search_video"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	localVarQueryParams.Add("keyword", parameterToString(keyword, ""))
	if localVarOptionals != nil && localVarOptionals.Count.IsSet() {
		localVarQueryParams.Add("count", parameterToString(localVarOptionals.Count.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SearchId.IsSet() {
		localVarQueryParams.Add("search_id", parameterToString(localVarOptionals.SearchId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Cookie.IsSet() {
		localVarQueryParams.Add("cookie", parameterToString(localVarOptionals.Cookie.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// TikTokWebAPIApiFetchSearchVideoApiV1TiktokWebFetchSearchVideoGet_13Opts Optional parameters for the method 'FetchSearchVideoApiV1TiktokWebFetchSearchVideoGet_13'
type TikTokWebAPIApiFetchSearchVideoApiV1TiktokWebFetchSearchVideoGet_13Opts struct {
	Count    optional.Int32
	Offset   optional.Int32
	SearchId optional.String
	Cookie   optional.String
}

/*
FetchSearchVideoApiV1TiktokWebFetchSearchVideoGet_0 搜索视频/Search video
# [中文] ### 用途: - 搜索视频 ### 参数: - keyword: 搜索关键词 - count: 每页数量，建议保持默认值20。 - cursor: 翻页游标，第一次请求时为0，第二次请求时从上一次请求的返回响应中获取，一般这个值的关键字为offset或者cursor。 - search_id: 搜索id，第一次请求时为空，第二次翻页时需要提供，需要从上一次请求的返回响应中获取。     - 例如: search_id &#x3D; \&quot;20240828035554C02011379EBB6A00E00B\&quot;     - JSON Path-1 : $.data.extra.logid     - JSON Path-2 : $.data.log_pb.impr_id - cookie: 用户cookie(如果你需要使用自己的账号搜索，或者遇到接口报错，可以自行提供cookie，默认不需要提供) ### 返回: - 视频列表  # [English] ### Purpose: - Search video ### Parameters: - keyword: Search keyword - count: Number per page, it is recommended to keep the default value 20. - cursor: Page cursor, 0 for the first request, need to provide for the second paging, generally the keyword of this value is offset or cursor. - search_id: Search id, empty for the first request, need to provide for the second paging, need to get it from the return response of the last request.     - For example: search_id &#x3D; \&quot;20240828035554C02011379EBB6A00E00B\&quot;     - JSON Path-1 : $.data.extra.logid     - JSON Path-2 : $.data.log_pb.impr_id - offset: Page cursor - cookie: User cookie (If you need to search with your own account, or encounter an interface error, you can provide the cookie yourself, default is not required) ### Return: - Video list  # [示例/Example] keyword &#x3D; \&quot;TikTok\&quot; count &#x3D; 20 offset &#x3D; 0 search_id &#x3D; \&quot;\&quot;
  - @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param keyword 搜索关键词/Search keyword
  - @param optional nil or *TikTokWebAPIApiFetchSearchVideoApiV1TiktokWebFetchSearchVideoGet_13Opts - Optional Parameters:
  - @param "Count" (optional.Int32) -  每页数量/Number per page
  - @param "Offset" (optional.Int32) -  翻页游标/Page cursor
  - @param "SearchId" (optional.String) -  搜索id，翻页时需要提供/Search id, need to provide when paging
  - @param "Cookie" (optional.String) -  用户cookie(按需提供)/User cookie(if needed)

@return ResponseModel
*/
func (a *TikTokWebAPIApiService) FetchSearchVideoApiV1TiktokWebFetchSearchVideoGet_13(ctx _context.Context, keyword string, localVarOptionals *TikTokWebAPIApiFetchSearchVideoApiV1TiktokWebFetchSearchVideoGet_13Opts) (ResponseModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResponseModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/tiktok/web/fetch_search_video"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	localVarQueryParams.Add("keyword", parameterToString(keyword, ""))
	if localVarOptionals != nil && localVarOptionals.Count.IsSet() {
		localVarQueryParams.Add("count", parameterToString(localVarOptionals.Count.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SearchId.IsSet() {
		localVarQueryParams.Add("search_id", parameterToString(localVarOptionals.SearchId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Cookie.IsSet() {
		localVarQueryParams.Add("cookie", parameterToString(localVarOptionals.Cookie.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
FetchTagDetailApiV1TiktokWebFetchTagDetailGet Tag详情/Tag Detail
# [中文] ### 用途: - Tag详情 ### 参数: - tag_name: Tag名称 ### 返回: - Tag详情  # [English] ### Purpose: - Tag Detail ### Parameters: - tag_name: Tag name ### Return: - Tag Detail  # [示例/Example] tag_name &#x3D; \&quot;tiktok\&quot;
  - @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param tagName Tag名称/Tag name

@return ResponseModel
*/
func (a *TikTokWebAPIApiService) FetchTagDetailApiV1TiktokWebFetchTagDetailGet(ctx _context.Context, tagName string) (ResponseModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResponseModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/tiktok/web/fetch_tag_detail"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	localVarQueryParams.Add("tag_name", parameterToString(tagName, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
FetchTagDetailApiV1TiktokWebFetchTagDetailGet_0 Tag详情/Tag Detail
# [中文] ### 用途: - Tag详情 ### 参数: - tag_name: Tag名称 ### 返回: - Tag详情  # [English] ### Purpose: - Tag Detail ### Parameters: - tag_name: Tag name ### Return: - Tag Detail  # [示例/Example] tag_name &#x3D; \&quot;tiktok\&quot;
  - @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param tagName Tag名称/Tag name

@return ResponseModel
*/
func (a *TikTokWebAPIApiService) FetchTagDetailApiV1TiktokWebFetchTagDetailGet_14(ctx _context.Context, tagName string) (ResponseModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResponseModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/tiktok/web/fetch_tag_detail"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	localVarQueryParams.Add("tag_name", parameterToString(tagName, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// TikTokWebAPIApiFetchTagPostApiV1TiktokWebFetchTagPostGetOpts Optional parameters for the method 'FetchTagPostApiV1TiktokWebFetchTagPostGet'
type TikTokWebAPIApiFetchTagPostApiV1TiktokWebFetchTagPostGetOpts struct {
	Count  optional.Int32
	Cursor optional.Int32
}

/*
FetchTagPostApiV1TiktokWebFetchTagPostGet Tag作品/Tag Post
# [中文] ### 用途: - Tag作品 ### 参数: - challengeID: Tag ID - count: 每页数量 - cursor: 翻页游标 ### 返回: - Tag作品  # [English] ### Purpose: - Tag Post ### Parameters: - challengeID: Tag ID - count: Number per page - cursor: Page cursor ### Return: - Tag Post  # [示例/Example] challengeID &#x3D; \&quot;7551\&quot; count &#x3D; 30 cursor &#x3D; 0
  - @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param challengeID Tag ID
  - @param optional nil or *TikTokWebAPIApiFetchTagPostApiV1TiktokWebFetchTagPostGetOpts - Optional Parameters:
  - @param "Count" (optional.Int32) -  每页数量/Number per page
  - @param "Cursor" (optional.Int32) -  翻页游标/Page cursor

@return ResponseModel
*/
func (a *TikTokWebAPIApiService) FetchTagPostApiV1TiktokWebFetchTagPostGet(ctx _context.Context, challengeID string, localVarOptionals *TikTokWebAPIApiFetchTagPostApiV1TiktokWebFetchTagPostGetOpts) (ResponseModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResponseModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/tiktok/web/fetch_tag_post"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	localVarQueryParams.Add("challengeID", parameterToString(challengeID, ""))
	if localVarOptionals != nil && localVarOptionals.Count.IsSet() {
		localVarQueryParams.Add("count", parameterToString(localVarOptionals.Count.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Cursor.IsSet() {
		localVarQueryParams.Add("cursor", parameterToString(localVarOptionals.Cursor.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// TikTokWebAPIApiFetchTagPostApiV1TiktokWebFetchTagPostGet_15Opts Optional parameters for the method 'FetchTagPostApiV1TiktokWebFetchTagPostGet_15'
type TikTokWebAPIApiFetchTagPostApiV1TiktokWebFetchTagPostGet_15Opts struct {
	Count  optional.Int32
	Cursor optional.Int32
}

/*
FetchTagPostApiV1TiktokWebFetchTagPostGet_0 Tag作品/Tag Post
# [中文] ### 用途: - Tag作品 ### 参数: - challengeID: Tag ID - count: 每页数量 - cursor: 翻页游标 ### 返回: - Tag作品  # [English] ### Purpose: - Tag Post ### Parameters: - challengeID: Tag ID - count: Number per page - cursor: Page cursor ### Return: - Tag Post  # [示例/Example] challengeID &#x3D; \&quot;7551\&quot; count &#x3D; 30 cursor &#x3D; 0
  - @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param challengeID Tag ID
  - @param optional nil or *TikTokWebAPIApiFetchTagPostApiV1TiktokWebFetchTagPostGet_15Opts - Optional Parameters:
  - @param "Count" (optional.Int32) -  每页数量/Number per page
  - @param "Cursor" (optional.Int32) -  翻页游标/Page cursor

@return ResponseModel
*/
func (a *TikTokWebAPIApiService) FetchTagPostApiV1TiktokWebFetchTagPostGet_15(ctx _context.Context, challengeID string, localVarOptionals *TikTokWebAPIApiFetchTagPostApiV1TiktokWebFetchTagPostGet_15Opts) (ResponseModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResponseModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/tiktok/web/fetch_tag_post"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	localVarQueryParams.Add("challengeID", parameterToString(challengeID, ""))
	if localVarOptionals != nil && localVarOptionals.Count.IsSet() {
		localVarQueryParams.Add("count", parameterToString(localVarOptionals.Count.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Cursor.IsSet() {
		localVarQueryParams.Add("cursor", parameterToString(localVarOptionals.Cursor.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
FetchTiktokLiveDataApiV1TiktokWebFetchTiktokLiveDataGet 通过直播链接获取直播间信息/Get live room information via live link
# [中文] ### 用途: - 通过直播链接获取直播间信息 - 此接口可获取离线直播间信息 ### 参数: - live_room_url: 直播间链接 ### 返回: - 直播间信息  # [English] ### Purpose: - Get live room information via live link - This interface can get offline live room information ### Parameters: - live_room_url: Live room link ### Return: - Live room information  # [示例/Example] live_room_url &#x3D; \&quot;https://www.tiktok.com/@.caseoh_daily/live\&quot;
  - @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param liveRoomUrl 直播间链接/Live room link

@return ResponseModel
*/
func (a *TikTokWebAPIApiService) FetchTiktokLiveDataApiV1TiktokWebFetchTiktokLiveDataGet(ctx _context.Context, liveRoomUrl string) (ResponseModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResponseModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/tiktok/web/fetch_tiktok_live_data"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	localVarQueryParams.Add("live_room_url", parameterToString(liveRoomUrl, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
FetchTiktokLiveDataApiV1TiktokWebFetchTiktokLiveDataGet_0 通过直播链接获取直播间信息/Get live room information via live link
# [中文] ### 用途: - 通过直播链接获取直播间信息 - 此接口可获取离线直播间信息 ### 参数: - live_room_url: 直播间链接 ### 返回: - 直播间信息  # [English] ### Purpose: - Get live room information via live link - This interface can get offline live room information ### Parameters: - live_room_url: Live room link ### Return: - Live room information  # [示例/Example] live_room_url &#x3D; \&quot;https://www.tiktok.com/@.caseoh_daily/live\&quot;
  - @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param liveRoomUrl 直播间链接/Live room link

@return ResponseModel
*/
func (a *TikTokWebAPIApiService) FetchTiktokLiveDataApiV1TiktokWebFetchTiktokLiveDataGet_16(ctx _context.Context, liveRoomUrl string) (ResponseModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResponseModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/tiktok/web/fetch_tiktok_live_data"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	localVarQueryParams.Add("live_room_url", parameterToString(liveRoomUrl, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
FetchTrendingPostApiV1TiktokWebFetchTrendingPostGet 获取每日热门内容作品数据/Get daily trending video data
# [中文] ### 用途: - 获取每日热门内容作品数据 ### 返回: - 作品数据  # [English] ### Purpose: - Get daily trending video data ### Return: - Video data  # [示例/Example]
  - @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().

@return ResponseModel
*/
func (a *TikTokWebAPIApiService) FetchTrendingPostApiV1TiktokWebFetchTrendingPostGet(ctx _context.Context) (ResponseModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResponseModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/tiktok/web/fetch_trending_post"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
FetchTrendingPostApiV1TiktokWebFetchTrendingPostGet_0 获取每日热门内容作品数据/Get daily trending video data
# [中文] ### 用途: - 获取每日热门内容作品数据 ### 返回: - 作品数据  # [English] ### Purpose: - Get daily trending video data ### Return: - Video data  # [示例/Example]
  - @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().

@return ResponseModel
*/
func (a *TikTokWebAPIApiService) FetchTrendingPostApiV1TiktokWebFetchTrendingPostGet_17(ctx _context.Context) (ResponseModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResponseModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/tiktok/web/fetch_trending_post"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// TikTokWebAPIApiFetchUserCollectApiV1TiktokWebFetchUserCollectGetOpts Optional parameters for the method 'FetchUserCollectApiV1TiktokWebFetchUserCollectGet'
type TikTokWebAPIApiFetchUserCollectApiV1TiktokWebFetchUserCollectGetOpts struct {
	Cursor      optional.Int32
	Count       optional.Int32
	CoverFormat optional.Int32
}

/*
FetchUserCollectApiV1TiktokWebFetchUserCollectGet 获取用户的收藏列表/Get user favorites
# [中文] ### 用途: - 获取用户的收藏列表 - 注意: 该接口目前只能获取自己的收藏列表，需要提供自己账号的cookie。 ### 参数: - cookie: 用户cookie - secUid: 用户secUid - cursor: 翻页游标 - count: 每页数量 - coverFormat: 封面格式 ### 返回: - 用户的收藏列表  # [English] ### Purpose: - Get user favorites - Note: This interface can currently only get your own favorites list, you need to provide your account cookie. ### Parameters: - cookie: User cookie - secUid: User secUid - cursor: Page cursor - count: Number per page - coverFormat: Cover format ### Return: - User favorites  # [示例/Example] cookie &#x3D; \&quot;Your_Cookie\&quot; secUid &#x3D; \&quot;Your_SecUid\&quot; cursor &#x3D; 0 count &#x3D; 30 coverFormat &#x3D; 2
  - @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param cookie 用户cookie/User cookie
  - @param secUid 用户secUid/User secUid
  - @param optional nil or *TikTokWebAPIApiFetchUserCollectApiV1TiktokWebFetchUserCollectGetOpts - Optional Parameters:
  - @param "Cursor" (optional.Int32) -  翻页游标/Page cursor
  - @param "Count" (optional.Int32) -  每页数量/Number per page
  - @param "CoverFormat" (optional.Int32) -  封面格式/Cover format

@return ResponseModel
*/
func (a *TikTokWebAPIApiService) FetchUserCollectApiV1TiktokWebFetchUserCollectGet(ctx _context.Context, cookie string, secUid string, localVarOptionals *TikTokWebAPIApiFetchUserCollectApiV1TiktokWebFetchUserCollectGetOpts) (ResponseModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResponseModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/tiktok/web/fetch_user_collect"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	localVarQueryParams.Add("cookie", parameterToString(cookie, ""))
	localVarQueryParams.Add("secUid", parameterToString(secUid, ""))
	if localVarOptionals != nil && localVarOptionals.Cursor.IsSet() {
		localVarQueryParams.Add("cursor", parameterToString(localVarOptionals.Cursor.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Count.IsSet() {
		localVarQueryParams.Add("count", parameterToString(localVarOptionals.Count.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CoverFormat.IsSet() {
		localVarQueryParams.Add("coverFormat", parameterToString(localVarOptionals.CoverFormat.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// TikTokWebAPIApiFetchUserCollectApiV1TiktokWebFetchUserCollectGet_18Opts Optional parameters for the method 'FetchUserCollectApiV1TiktokWebFetchUserCollectGet_18'
type TikTokWebAPIApiFetchUserCollectApiV1TiktokWebFetchUserCollectGet_18Opts struct {
	Cursor      optional.Int32
	Count       optional.Int32
	CoverFormat optional.Int32
}

/*
FetchUserCollectApiV1TiktokWebFetchUserCollectGet_0 获取用户的收藏列表/Get user favorites
# [中文] ### 用途: - 获取用户的收藏列表 - 注意: 该接口目前只能获取自己的收藏列表，需要提供自己账号的cookie。 ### 参数: - cookie: 用户cookie - secUid: 用户secUid - cursor: 翻页游标 - count: 每页数量 - coverFormat: 封面格式 ### 返回: - 用户的收藏列表  # [English] ### Purpose: - Get user favorites - Note: This interface can currently only get your own favorites list, you need to provide your account cookie. ### Parameters: - cookie: User cookie - secUid: User secUid - cursor: Page cursor - count: Number per page - coverFormat: Cover format ### Return: - User favorites  # [示例/Example] cookie &#x3D; \&quot;Your_Cookie\&quot; secUid &#x3D; \&quot;Your_SecUid\&quot; cursor &#x3D; 0 count &#x3D; 30 coverFormat &#x3D; 2
  - @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param cookie 用户cookie/User cookie
  - @param secUid 用户secUid/User secUid
  - @param optional nil or *TikTokWebAPIApiFetchUserCollectApiV1TiktokWebFetchUserCollectGet_18Opts - Optional Parameters:
  - @param "Cursor" (optional.Int32) -  翻页游标/Page cursor
  - @param "Count" (optional.Int32) -  每页数量/Number per page
  - @param "CoverFormat" (optional.Int32) -  封面格式/Cover format

@return ResponseModel
*/
func (a *TikTokWebAPIApiService) FetchUserCollectApiV1TiktokWebFetchUserCollectGet_18(ctx _context.Context, cookie string, secUid string, localVarOptionals *TikTokWebAPIApiFetchUserCollectApiV1TiktokWebFetchUserCollectGet_18Opts) (ResponseModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResponseModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/tiktok/web/fetch_user_collect"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	localVarQueryParams.Add("cookie", parameterToString(cookie, ""))
	localVarQueryParams.Add("secUid", parameterToString(secUid, ""))
	if localVarOptionals != nil && localVarOptionals.Cursor.IsSet() {
		localVarQueryParams.Add("cursor", parameterToString(localVarOptionals.Cursor.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Count.IsSet() {
		localVarQueryParams.Add("count", parameterToString(localVarOptionals.Count.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CoverFormat.IsSet() {
		localVarQueryParams.Add("coverFormat", parameterToString(localVarOptionals.CoverFormat.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// TikTokWebAPIApiFetchUserFansApiV1TiktokWebFetchUserFansGetOpts Optional parameters for the method 'FetchUserFansApiV1TiktokWebFetchUserFansGet'
type TikTokWebAPIApiFetchUserFansApiV1TiktokWebFetchUserFansGetOpts struct {
	Count     optional.Int32
	MaxCursor optional.Int32
	MinCursor optional.Int32
}

/*
FetchUserFansApiV1TiktokWebFetchUserFansGet 获取用户的粉丝列表/Get user followers
# [中文] ### 用途: - 获取用户的粉丝列表 ### 参数: - secUid: 用户secUid - count: 每页数量 - maxCursor: 最大游标 - minCursor: 最小游标 ### 返回: - 用户的粉丝列表  # [English] ### Purpose: - Get user followers ### Parameters: - secUid: User secUid - count: Number per page - maxCursor: Max cursor - minCursor: Min cursor ### Return: - User followers  # [示例/Example] secUid &#x3D; \&quot;MS4wLjABAAAAv7iSuuXDJGDvJkmH_vz1qkDZYo1apxgzaxdBSeIuPiM\&quot; count &#x3D; 30 maxCursor &#x3D; 0 minCursor &#x3D; 0
  - @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param secUid 用户secUid/User secUid
  - @param optional nil or *TikTokWebAPIApiFetchUserFansApiV1TiktokWebFetchUserFansGetOpts - Optional Parameters:
  - @param "Count" (optional.Int32) -  每页数量/Number per page
  - @param "MaxCursor" (optional.Int32) -  最大游标/Max cursor
  - @param "MinCursor" (optional.Int32) -  最小游标/Min cursor

@return ResponseModel
*/
func (a *TikTokWebAPIApiService) FetchUserFansApiV1TiktokWebFetchUserFansGet(ctx _context.Context, secUid string, localVarOptionals *TikTokWebAPIApiFetchUserFansApiV1TiktokWebFetchUserFansGetOpts) (ResponseModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResponseModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/tiktok/web/fetch_user_fans"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	localVarQueryParams.Add("secUid", parameterToString(secUid, ""))
	if localVarOptionals != nil && localVarOptionals.Count.IsSet() {
		localVarQueryParams.Add("count", parameterToString(localVarOptionals.Count.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MaxCursor.IsSet() {
		localVarQueryParams.Add("maxCursor", parameterToString(localVarOptionals.MaxCursor.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MinCursor.IsSet() {
		localVarQueryParams.Add("minCursor", parameterToString(localVarOptionals.MinCursor.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// TikTokWebAPIApiFetchUserFansApiV1TiktokWebFetchUserFansGet_19Opts Optional parameters for the method 'FetchUserFansApiV1TiktokWebFetchUserFansGet_19'
type TikTokWebAPIApiFetchUserFansApiV1TiktokWebFetchUserFansGet_19Opts struct {
	Count     optional.Int32
	MaxCursor optional.Int32
	MinCursor optional.Int32
}

/*
FetchUserFansApiV1TiktokWebFetchUserFansGet_0 获取用户的粉丝列表/Get user followers
# [中文] ### 用途: - 获取用户的粉丝列表 ### 参数: - secUid: 用户secUid - count: 每页数量 - maxCursor: 最大游标 - minCursor: 最小游标 ### 返回: - 用户的粉丝列表  # [English] ### Purpose: - Get user followers ### Parameters: - secUid: User secUid - count: Number per page - maxCursor: Max cursor - minCursor: Min cursor ### Return: - User followers  # [示例/Example] secUid &#x3D; \&quot;MS4wLjABAAAAv7iSuuXDJGDvJkmH_vz1qkDZYo1apxgzaxdBSeIuPiM\&quot; count &#x3D; 30 maxCursor &#x3D; 0 minCursor &#x3D; 0
  - @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param secUid 用户secUid/User secUid
  - @param optional nil or *TikTokWebAPIApiFetchUserFansApiV1TiktokWebFetchUserFansGet_19Opts - Optional Parameters:
  - @param "Count" (optional.Int32) -  每页数量/Number per page
  - @param "MaxCursor" (optional.Int32) -  最大游标/Max cursor
  - @param "MinCursor" (optional.Int32) -  最小游标/Min cursor

@return ResponseModel
*/
func (a *TikTokWebAPIApiService) FetchUserFansApiV1TiktokWebFetchUserFansGet_19(ctx _context.Context, secUid string, localVarOptionals *TikTokWebAPIApiFetchUserFansApiV1TiktokWebFetchUserFansGet_19Opts) (ResponseModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResponseModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/tiktok/web/fetch_user_fans"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	localVarQueryParams.Add("secUid", parameterToString(secUid, ""))
	if localVarOptionals != nil && localVarOptionals.Count.IsSet() {
		localVarQueryParams.Add("count", parameterToString(localVarOptionals.Count.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MaxCursor.IsSet() {
		localVarQueryParams.Add("maxCursor", parameterToString(localVarOptionals.MaxCursor.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MinCursor.IsSet() {
		localVarQueryParams.Add("minCursor", parameterToString(localVarOptionals.MinCursor.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// TikTokWebAPIApiFetchUserFollowApiV1TiktokWebFetchUserFollowGetOpts Optional parameters for the method 'FetchUserFollowApiV1TiktokWebFetchUserFollowGet'
type TikTokWebAPIApiFetchUserFollowApiV1TiktokWebFetchUserFollowGetOpts struct {
	Count     optional.Int32
	MaxCursor optional.Int32
	MinCursor optional.Int32
}

/*
FetchUserFollowApiV1TiktokWebFetchUserFollowGet 获取用户的关注列表/Get user followings
# [中文] ### 用途: - 获取用户的关注列表 ### 参数: - secUid: 用户secUid - count: 每页数量 - maxCursor: 最大游标 - minCursor: 最小游标 ### 返回: - 用户的关注列表  # [English] ### Purpose: - Get user followings ### Parameters: - secUid: User secUid - count: Number per page - maxCursor: Max cursor - minCursor: Min cursor ### Return: - User followings  # [示例/Example] secUid &#x3D; \&quot;MS4wLjABAAAAv7iSuuXDJGDvJkmH_vz1qkDZYo1apxgzaxdBSeIuPiM\&quot; count &#x3D; 30 maxCursor &#x3D; 0 minCursor &#x3D; 0
  - @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param secUid 用户secUid/User secUid
  - @param optional nil or *TikTokWebAPIApiFetchUserFollowApiV1TiktokWebFetchUserFollowGetOpts - Optional Parameters:
  - @param "Count" (optional.Int32) -  每页数量/Number per page
  - @param "MaxCursor" (optional.Int32) -  最大游标/Max cursor
  - @param "MinCursor" (optional.Int32) -  最小游标/Min cursor

@return ResponseModel
*/
func (a *TikTokWebAPIApiService) FetchUserFollowApiV1TiktokWebFetchUserFollowGet(ctx _context.Context, secUid string, localVarOptionals *TikTokWebAPIApiFetchUserFollowApiV1TiktokWebFetchUserFollowGetOpts) (ResponseModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResponseModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/tiktok/web/fetch_user_follow"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	localVarQueryParams.Add("secUid", parameterToString(secUid, ""))
	if localVarOptionals != nil && localVarOptionals.Count.IsSet() {
		localVarQueryParams.Add("count", parameterToString(localVarOptionals.Count.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MaxCursor.IsSet() {
		localVarQueryParams.Add("maxCursor", parameterToString(localVarOptionals.MaxCursor.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MinCursor.IsSet() {
		localVarQueryParams.Add("minCursor", parameterToString(localVarOptionals.MinCursor.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// TikTokWebAPIApiFetchUserFollowApiV1TiktokWebFetchUserFollowGet_20Opts Optional parameters for the method 'FetchUserFollowApiV1TiktokWebFetchUserFollowGet_20'
type TikTokWebAPIApiFetchUserFollowApiV1TiktokWebFetchUserFollowGet_20Opts struct {
	Count     optional.Int32
	MaxCursor optional.Int32
	MinCursor optional.Int32
}

/*
FetchUserFollowApiV1TiktokWebFetchUserFollowGet_0 获取用户的关注列表/Get user followings
# [中文] ### 用途: - 获取用户的关注列表 ### 参数: - secUid: 用户secUid - count: 每页数量 - maxCursor: 最大游标 - minCursor: 最小游标 ### 返回: - 用户的关注列表  # [English] ### Purpose: - Get user followings ### Parameters: - secUid: User secUid - count: Number per page - maxCursor: Max cursor - minCursor: Min cursor ### Return: - User followings  # [示例/Example] secUid &#x3D; \&quot;MS4wLjABAAAAv7iSuuXDJGDvJkmH_vz1qkDZYo1apxgzaxdBSeIuPiM\&quot; count &#x3D; 30 maxCursor &#x3D; 0 minCursor &#x3D; 0
  - @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param secUid 用户secUid/User secUid
  - @param optional nil or *TikTokWebAPIApiFetchUserFollowApiV1TiktokWebFetchUserFollowGet_20Opts - Optional Parameters:
  - @param "Count" (optional.Int32) -  每页数量/Number per page
  - @param "MaxCursor" (optional.Int32) -  最大游标/Max cursor
  - @param "MinCursor" (optional.Int32) -  最小游标/Min cursor

@return ResponseModel
*/
func (a *TikTokWebAPIApiService) FetchUserFollowApiV1TiktokWebFetchUserFollowGet_20(ctx _context.Context, secUid string, localVarOptionals *TikTokWebAPIApiFetchUserFollowApiV1TiktokWebFetchUserFollowGet_20Opts) (ResponseModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResponseModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/tiktok/web/fetch_user_follow"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	localVarQueryParams.Add("secUid", parameterToString(secUid, ""))
	if localVarOptionals != nil && localVarOptionals.Count.IsSet() {
		localVarQueryParams.Add("count", parameterToString(localVarOptionals.Count.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MaxCursor.IsSet() {
		localVarQueryParams.Add("maxCursor", parameterToString(localVarOptionals.MaxCursor.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MinCursor.IsSet() {
		localVarQueryParams.Add("minCursor", parameterToString(localVarOptionals.MinCursor.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// TikTokWebAPIApiFetchUserLikeApiV1TiktokWebFetchUserLikeGetOpts Optional parameters for the method 'FetchUserLikeApiV1TiktokWebFetchUserLikeGet'
type TikTokWebAPIApiFetchUserLikeApiV1TiktokWebFetchUserLikeGetOpts struct {
	Cursor                  optional.Int32
	Count                   optional.Int32
	CoverFormat             optional.Int32
	PostItemListRequestType optional.Int32
}

/*
FetchUserLikeApiV1TiktokWebFetchUserLikeGet 获取用户的点赞列表/Get user likes
# [中文] ### 用途: - 获取用户的点赞列表 - 注意: 该接口需要用户点赞列表为公开状态 ### 参数: - secUid: 用户secUid - cursor: 翻页游标 - count: 每页数量，默认为20，不可变更。 - coverFormat: 封面格式 - post_item_list_request_type: 排序方式     - 0：默认排序     - 1：热门排序     - 2：最旧排序 ### 返回: - 用户的点赞列表  # [English] ### Purpose: - Get user likes - Note: This interface requires that the user&#39;s like list be public ### Parameters: - secUid: User secUid - cursor: Page cursor - count: Number per page, default is 20, cannot be changed. - coverFormat: Cover format - post_item_list_request_type: Sort type     - 0: Default sort     - 1: Hot sort     - 2: Oldest sort ### Return: - User likes  # [示例/Example] secUid &#x3D; \&quot;MS4wLjABAAAAq1iRXNduFZpY301UkVpJ1eQT60_NiWS9QQSeNqmNQEDJp0pOF8cpleNEdiJx5_IU\&quot; cursor &#x3D; 0 count &#x3D; 20 coverFormat &#x3D; 2
  - @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param secUid 用户secUid/User secUid
  - @param optional nil or *TikTokWebAPIApiFetchUserLikeApiV1TiktokWebFetchUserLikeGetOpts - Optional Parameters:
  - @param "Cursor" (optional.Int32) -  翻页游标/Page cursor
  - @param "Count" (optional.Int32) -  每页数量/Number per page
  - @param "CoverFormat" (optional.Int32) -  封面格式/Cover format
  - @param "PostItemListRequestType" (optional.Int32) -  排序方式/Sort type

@return ResponseModel
*/
func (a *TikTokWebAPIApiService) FetchUserLikeApiV1TiktokWebFetchUserLikeGet(ctx _context.Context, secUid string, localVarOptionals *TikTokWebAPIApiFetchUserLikeApiV1TiktokWebFetchUserLikeGetOpts) (ResponseModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResponseModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/tiktok/web/fetch_user_like"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	localVarQueryParams.Add("secUid", parameterToString(secUid, ""))
	if localVarOptionals != nil && localVarOptionals.Cursor.IsSet() {
		localVarQueryParams.Add("cursor", parameterToString(localVarOptionals.Cursor.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Count.IsSet() {
		localVarQueryParams.Add("count", parameterToString(localVarOptionals.Count.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CoverFormat.IsSet() {
		localVarQueryParams.Add("coverFormat", parameterToString(localVarOptionals.CoverFormat.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PostItemListRequestType.IsSet() {
		localVarQueryParams.Add("post_item_list_request_type", parameterToString(localVarOptionals.PostItemListRequestType.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// TikTokWebAPIApiFetchUserLikeApiV1TiktokWebFetchUserLikeGet_21Opts Optional parameters for the method 'FetchUserLikeApiV1TiktokWebFetchUserLikeGet_21'
type TikTokWebAPIApiFetchUserLikeApiV1TiktokWebFetchUserLikeGet_21Opts struct {
	Cursor                  optional.Int32
	Count                   optional.Int32
	CoverFormat             optional.Int32
	PostItemListRequestType optional.Int32
}

/*
FetchUserLikeApiV1TiktokWebFetchUserLikeGet_0 获取用户的点赞列表/Get user likes
# [中文] ### 用途: - 获取用户的点赞列表 - 注意: 该接口需要用户点赞列表为公开状态 ### 参数: - secUid: 用户secUid - cursor: 翻页游标 - count: 每页数量，默认为20，不可变更。 - coverFormat: 封面格式 - post_item_list_request_type: 排序方式     - 0：默认排序     - 1：热门排序     - 2：最旧排序 ### 返回: - 用户的点赞列表  # [English] ### Purpose: - Get user likes - Note: This interface requires that the user&#39;s like list be public ### Parameters: - secUid: User secUid - cursor: Page cursor - count: Number per page, default is 20, cannot be changed. - coverFormat: Cover format - post_item_list_request_type: Sort type     - 0: Default sort     - 1: Hot sort     - 2: Oldest sort ### Return: - User likes  # [示例/Example] secUid &#x3D; \&quot;MS4wLjABAAAAq1iRXNduFZpY301UkVpJ1eQT60_NiWS9QQSeNqmNQEDJp0pOF8cpleNEdiJx5_IU\&quot; cursor &#x3D; 0 count &#x3D; 20 coverFormat &#x3D; 2
  - @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param secUid 用户secUid/User secUid
  - @param optional nil or *TikTokWebAPIApiFetchUserLikeApiV1TiktokWebFetchUserLikeGet_21Opts - Optional Parameters:
  - @param "Cursor" (optional.Int32) -  翻页游标/Page cursor
  - @param "Count" (optional.Int32) -  每页数量/Number per page
  - @param "CoverFormat" (optional.Int32) -  封面格式/Cover format
  - @param "PostItemListRequestType" (optional.Int32) -  排序方式/Sort type

@return ResponseModel
*/
func (a *TikTokWebAPIApiService) FetchUserLikeApiV1TiktokWebFetchUserLikeGet_21(ctx _context.Context, secUid string, localVarOptionals *TikTokWebAPIApiFetchUserLikeApiV1TiktokWebFetchUserLikeGet_21Opts) (ResponseModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResponseModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/tiktok/web/fetch_user_like"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	localVarQueryParams.Add("secUid", parameterToString(secUid, ""))
	if localVarOptionals != nil && localVarOptionals.Cursor.IsSet() {
		localVarQueryParams.Add("cursor", parameterToString(localVarOptionals.Cursor.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Count.IsSet() {
		localVarQueryParams.Add("count", parameterToString(localVarOptionals.Count.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CoverFormat.IsSet() {
		localVarQueryParams.Add("coverFormat", parameterToString(localVarOptionals.CoverFormat.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PostItemListRequestType.IsSet() {
		localVarQueryParams.Add("post_item_list_request_type", parameterToString(localVarOptionals.PostItemListRequestType.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// TikTokWebAPIApiFetchUserMixApiV1TiktokWebFetchUserMixGetOpts Optional parameters for the method 'FetchUserMixApiV1TiktokWebFetchUserMixGet'
type TikTokWebAPIApiFetchUserMixApiV1TiktokWebFetchUserMixGetOpts struct {
	Cursor optional.Int32
	Count  optional.Int32
}

/*
FetchUserMixApiV1TiktokWebFetchUserMixGet 获取用户的合辑列表/Get user mix list
# [中文] ### 用途: - 获取用户的合辑列表 ### 参数: - mixId: 合辑id - cursor: 翻页游标 - count: 每页数量 ### 返回: - 用户的合辑列表  # [English] ### Purpose: - Get user mix list ### Parameters: - mixId: Mix id - cursor: Page cursor - count: Number per page ### Return: - User mix list  # [示例/Eample] mixId &#x3D; \&quot;7101538765474106158\&quot; cursor &#x3D; 0 count &#x3D; 30
  - @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param mixId 合辑id/Mix id
  - @param optional nil or *TikTokWebAPIApiFetchUserMixApiV1TiktokWebFetchUserMixGetOpts - Optional Parameters:
  - @param "Cursor" (optional.Int32) -  翻页游标/Page cursor
  - @param "Count" (optional.Int32) -  每页数量/Number per page

@return ResponseModel
*/
func (a *TikTokWebAPIApiService) FetchUserMixApiV1TiktokWebFetchUserMixGet(ctx _context.Context, mixId string, localVarOptionals *TikTokWebAPIApiFetchUserMixApiV1TiktokWebFetchUserMixGetOpts) (ResponseModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResponseModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/tiktok/web/fetch_user_mix"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	localVarQueryParams.Add("mixId", parameterToString(mixId, ""))
	if localVarOptionals != nil && localVarOptionals.Cursor.IsSet() {
		localVarQueryParams.Add("cursor", parameterToString(localVarOptionals.Cursor.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Count.IsSet() {
		localVarQueryParams.Add("count", parameterToString(localVarOptionals.Count.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// TikTokWebAPIApiFetchUserMixApiV1TiktokWebFetchUserMixGet_22Opts Optional parameters for the method 'FetchUserMixApiV1TiktokWebFetchUserMixGet_22'
type TikTokWebAPIApiFetchUserMixApiV1TiktokWebFetchUserMixGet_22Opts struct {
	Cursor optional.Int32
	Count  optional.Int32
}

/*
FetchUserMixApiV1TiktokWebFetchUserMixGet_0 获取用户的合辑列表/Get user mix list
# [中文] ### 用途: - 获取用户的合辑列表 ### 参数: - mixId: 合辑id - cursor: 翻页游标 - count: 每页数量 ### 返回: - 用户的合辑列表  # [English] ### Purpose: - Get user mix list ### Parameters: - mixId: Mix id - cursor: Page cursor - count: Number per page ### Return: - User mix list  # [示例/Eample] mixId &#x3D; \&quot;7101538765474106158\&quot; cursor &#x3D; 0 count &#x3D; 30
  - @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param mixId 合辑id/Mix id
  - @param optional nil or *TikTokWebAPIApiFetchUserMixApiV1TiktokWebFetchUserMixGet_22Opts - Optional Parameters:
  - @param "Cursor" (optional.Int32) -  翻页游标/Page cursor
  - @param "Count" (optional.Int32) -  每页数量/Number per page

@return ResponseModel
*/
func (a *TikTokWebAPIApiService) FetchUserMixApiV1TiktokWebFetchUserMixGet_22(ctx _context.Context, mixId string, localVarOptionals *TikTokWebAPIApiFetchUserMixApiV1TiktokWebFetchUserMixGet_22Opts) (ResponseModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResponseModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/tiktok/web/fetch_user_mix"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	localVarQueryParams.Add("mixId", parameterToString(mixId, ""))
	if localVarOptionals != nil && localVarOptionals.Cursor.IsSet() {
		localVarQueryParams.Add("cursor", parameterToString(localVarOptionals.Cursor.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Count.IsSet() {
		localVarQueryParams.Add("count", parameterToString(localVarOptionals.Count.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// TikTokWebAPIApiFetchUserPlayListApiV1TiktokWebFetchUserPlayListGetOpts Optional parameters for the method 'FetchUserPlayListApiV1TiktokWebFetchUserPlayListGet'
type TikTokWebAPIApiFetchUserPlayListApiV1TiktokWebFetchUserPlayListGetOpts struct {
	Cursor optional.Int32
	Count  optional.Int32
}

/*
FetchUserPlayListApiV1TiktokWebFetchUserPlayListGet 获取用户的播放列表/Get user play list
# [中文] ### 用途: - 获取用户的播放列表 ### 参数: - secUid: 用户secUid - cursor: 翻页游标 - count: 每页数量 ### 返回: - 用户的播放列表  # [English] ### Purpose: - Get user play list ### Parameters: - secUid: User secUid - cursor: Page cursor - count: Number per page ### Return: - User play list  # [示例/Eample] secUid &#x3D; \&quot;MS4wLjABAAAAv7iSuuXDJGDvJkmH_vz1qkDZYo1apxgzaxdBSeIuPiM\&quot; cursor &#x3D; 0 count &#x3D; 30
  - @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param secUid 用户secUid/User secUid
  - @param optional nil or *TikTokWebAPIApiFetchUserPlayListApiV1TiktokWebFetchUserPlayListGetOpts - Optional Parameters:
  - @param "Cursor" (optional.Int32) -  翻页游标/Page cursor
  - @param "Count" (optional.Int32) -  每页数量/Number per page

@return ResponseModel
*/
func (a *TikTokWebAPIApiService) FetchUserPlayListApiV1TiktokWebFetchUserPlayListGet(ctx _context.Context, secUid string, localVarOptionals *TikTokWebAPIApiFetchUserPlayListApiV1TiktokWebFetchUserPlayListGetOpts) (ResponseModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResponseModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/tiktok/web/fetch_user_play_list"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	localVarQueryParams.Add("secUid", parameterToString(secUid, ""))
	if localVarOptionals != nil && localVarOptionals.Cursor.IsSet() {
		localVarQueryParams.Add("cursor", parameterToString(localVarOptionals.Cursor.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Count.IsSet() {
		localVarQueryParams.Add("count", parameterToString(localVarOptionals.Count.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// TikTokWebAPIApiFetchUserPlayListApiV1TiktokWebFetchUserPlayListGet_23Opts Optional parameters for the method 'FetchUserPlayListApiV1TiktokWebFetchUserPlayListGet_23'
type TikTokWebAPIApiFetchUserPlayListApiV1TiktokWebFetchUserPlayListGet_23Opts struct {
	Cursor optional.Int32
	Count  optional.Int32
}

/*
FetchUserPlayListApiV1TiktokWebFetchUserPlayListGet_0 获取用户的播放列表/Get user play list
# [中文] ### 用途: - 获取用户的播放列表 ### 参数: - secUid: 用户secUid - cursor: 翻页游标 - count: 每页数量 ### 返回: - 用户的播放列表  # [English] ### Purpose: - Get user play list ### Parameters: - secUid: User secUid - cursor: Page cursor - count: Number per page ### Return: - User play list  # [示例/Eample] secUid &#x3D; \&quot;MS4wLjABAAAAv7iSuuXDJGDvJkmH_vz1qkDZYo1apxgzaxdBSeIuPiM\&quot; cursor &#x3D; 0 count &#x3D; 30
  - @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param secUid 用户secUid/User secUid
  - @param optional nil or *TikTokWebAPIApiFetchUserPlayListApiV1TiktokWebFetchUserPlayListGet_23Opts - Optional Parameters:
  - @param "Cursor" (optional.Int32) -  翻页游标/Page cursor
  - @param "Count" (optional.Int32) -  每页数量/Number per page

@return ResponseModel
*/
func (a *TikTokWebAPIApiService) FetchUserPlayListApiV1TiktokWebFetchUserPlayListGet_23(ctx _context.Context, secUid string, localVarOptionals *TikTokWebAPIApiFetchUserPlayListApiV1TiktokWebFetchUserPlayListGet_23Opts) (ResponseModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResponseModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/tiktok/web/fetch_user_play_list"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	localVarQueryParams.Add("secUid", parameterToString(secUid, ""))
	if localVarOptionals != nil && localVarOptionals.Cursor.IsSet() {
		localVarQueryParams.Add("cursor", parameterToString(localVarOptionals.Cursor.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Count.IsSet() {
		localVarQueryParams.Add("count", parameterToString(localVarOptionals.Count.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// TikTokWebAPIApiFetchUserPostApiV1TiktokWebFetchUserPostGetOpts Optional parameters for the method 'FetchUserPostApiV1TiktokWebFetchUserPostGet'
type TikTokWebAPIApiFetchUserPostApiV1TiktokWebFetchUserPostGetOpts struct {
	Cursor                  optional.Int32
	Count                   optional.Int32
	CoverFormat             optional.Int32
	PostItemListRequestType optional.Int32
}

/*
FetchUserPostApiV1TiktokWebFetchUserPostGet 获取用户的作品列表/Get user posts
# [中文] ### 用途: - 获取用户的作品列表 ### 参数: - secUid: 用户secUid - cursor: 翻页游标 - count: 每页数量，默认为20，不可变更。 - coverFormat: 封面格式 - post_item_list_request_type: 排序方式     - 0：默认排序     - 1：热门排序     - 2：最旧排序 ### 返回: - 用户的作品列表  # [English] ### Purpose: - Get user posts ### Parameters: - secUid: User secUid - cursor: Page cursor - count: Number per page, default is 20, cannot be changed. - coverFormat: Cover format - post_item_list_request_type: Sort type     - 0: Default sort     - 1: Hot sort     - 2: Oldest sort ### Return: - User posts  # [示例/Example] secUid &#x3D; \&quot;MS4wLjABAAAAv7iSuuXDJGDvJkmH_vz1qkDZYo1apxgzaxdBSeIuPiM\&quot; cursor &#x3D; 0 count &#x3D; 20 coverFormat &#x3D; 2
  - @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param secUid 用户secUid/User secUid
  - @param optional nil or *TikTokWebAPIApiFetchUserPostApiV1TiktokWebFetchUserPostGetOpts - Optional Parameters:
  - @param "Cursor" (optional.Int32) -  翻页游标/Page cursor
  - @param "Count" (optional.Int32) -  每页数量/Number per page
  - @param "CoverFormat" (optional.Int32) -  封面格式/Cover format
  - @param "PostItemListRequestType" (optional.Int32) -  排序方式/Sort type

@return ResponseModel
*/
func (a *TikTokWebAPIApiService) FetchUserPostApiV1TiktokWebFetchUserPostGet(ctx _context.Context, secUid string, localVarOptionals *TikTokWebAPIApiFetchUserPostApiV1TiktokWebFetchUserPostGetOpts) (ResponseModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResponseModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/tiktok/web/fetch_user_post"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	localVarQueryParams.Add("secUid", parameterToString(secUid, ""))
	if localVarOptionals != nil && localVarOptionals.Cursor.IsSet() {
		localVarQueryParams.Add("cursor", parameterToString(localVarOptionals.Cursor.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Count.IsSet() {
		localVarQueryParams.Add("count", parameterToString(localVarOptionals.Count.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CoverFormat.IsSet() {
		localVarQueryParams.Add("coverFormat", parameterToString(localVarOptionals.CoverFormat.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PostItemListRequestType.IsSet() {
		localVarQueryParams.Add("post_item_list_request_type", parameterToString(localVarOptionals.PostItemListRequestType.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// TikTokWebAPIApiFetchUserPostApiV1TiktokWebFetchUserPostGet_24Opts Optional parameters for the method 'FetchUserPostApiV1TiktokWebFetchUserPostGet_24'
type TikTokWebAPIApiFetchUserPostApiV1TiktokWebFetchUserPostGet_24Opts struct {
	Cursor                  optional.Int32
	Count                   optional.Int32
	CoverFormat             optional.Int32
	PostItemListRequestType optional.Int32
}

/*
FetchUserPostApiV1TiktokWebFetchUserPostGet_0 获取用户的作品列表/Get user posts
# [中文] ### 用途: - 获取用户的作品列表 ### 参数: - secUid: 用户secUid - cursor: 翻页游标 - count: 每页数量，默认为20，不可变更。 - coverFormat: 封面格式 - post_item_list_request_type: 排序方式     - 0：默认排序     - 1：热门排序     - 2：最旧排序 ### 返回: - 用户的作品列表  # [English] ### Purpose: - Get user posts ### Parameters: - secUid: User secUid - cursor: Page cursor - count: Number per page, default is 20, cannot be changed. - coverFormat: Cover format - post_item_list_request_type: Sort type     - 0: Default sort     - 1: Hot sort     - 2: Oldest sort ### Return: - User posts  # [示例/Example] secUid &#x3D; \&quot;MS4wLjABAAAAv7iSuuXDJGDvJkmH_vz1qkDZYo1apxgzaxdBSeIuPiM\&quot; cursor &#x3D; 0 count &#x3D; 20 coverFormat &#x3D; 2
  - @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param secUid 用户secUid/User secUid
  - @param optional nil or *TikTokWebAPIApiFetchUserPostApiV1TiktokWebFetchUserPostGet_24Opts - Optional Parameters:
  - @param "Cursor" (optional.Int32) -  翻页游标/Page cursor
  - @param "Count" (optional.Int32) -  每页数量/Number per page
  - @param "CoverFormat" (optional.Int32) -  封面格式/Cover format
  - @param "PostItemListRequestType" (optional.Int32) -  排序方式/Sort type

@return ResponseModel
*/
func (a *TikTokWebAPIApiService) FetchUserPostApiV1TiktokWebFetchUserPostGet_24(ctx _context.Context, secUid string, localVarOptionals *TikTokWebAPIApiFetchUserPostApiV1TiktokWebFetchUserPostGet_24Opts) (ResponseModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResponseModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/tiktok/web/fetch_user_post"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	localVarQueryParams.Add("secUid", parameterToString(secUid, ""))
	if localVarOptionals != nil && localVarOptionals.Cursor.IsSet() {
		localVarQueryParams.Add("cursor", parameterToString(localVarOptionals.Cursor.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Count.IsSet() {
		localVarQueryParams.Add("count", parameterToString(localVarOptionals.Count.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CoverFormat.IsSet() {
		localVarQueryParams.Add("coverFormat", parameterToString(localVarOptionals.CoverFormat.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PostItemListRequestType.IsSet() {
		localVarQueryParams.Add("post_item_list_request_type", parameterToString(localVarOptionals.PostItemListRequestType.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// TikTokWebAPIApiFetchUserProfileApiV1TiktokWebFetchUserProfileGetOpts Optional parameters for the method 'FetchUserProfileApiV1TiktokWebFetchUserProfileGet'
type TikTokWebAPIApiFetchUserProfileApiV1TiktokWebFetchUserProfileGetOpts struct {
	UniqueId optional.String
	SecUid   optional.String
}

/*
FetchUserProfileApiV1TiktokWebFetchUserProfileGet 获取用户的个人信息/Get user profile
# [中文] ### 用途: - 获取用户的个人信息 ### 参数: - secUid: 用户secUid - uniqueId: 用户uniqueId - secUid和uniqueId至少提供一个, 优先使用uniqueId, 也就是用户主页的链接中的用户名。 ### 返回: - 用户的个人信息  # [English] ### Purpose: - Get user profile ### Parameters: - secUid: User secUid - uniqueId: User uniqueId - At least one of secUid and uniqueId is provided, and uniqueId is preferred, that is, the username in the user&#39;s homepage link. ### Return: - User profile  # [示例/Example] secUid &#x3D; \&quot;MS4wLjABAAAAv7iSuuXDJGDvJkmH_vz1qkDZYo1apxgzaxdBSeIuPiM\&quot; uniqueId &#x3D; \&quot;tiktok\&quot;
  - @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param optional nil or *TikTokWebAPIApiFetchUserProfileApiV1TiktokWebFetchUserProfileGetOpts - Optional Parameters:
  - @param "UniqueId" (optional.String) -  用户uniqueId/User uniqueId
  - @param "SecUid" (optional.String) -  用户secUid/User secUid

@return ResponseModel
*/
func (a *TikTokWebAPIApiService) FetchUserProfileApiV1TiktokWebFetchUserProfileGet(ctx _context.Context, localVarOptionals *TikTokWebAPIApiFetchUserProfileApiV1TiktokWebFetchUserProfileGetOpts) (ResponseModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResponseModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/tiktok/web/fetch_user_profile"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.UniqueId.IsSet() {
		localVarQueryParams.Add("uniqueId", parameterToString(localVarOptionals.UniqueId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SecUid.IsSet() {
		localVarQueryParams.Add("secUid", parameterToString(localVarOptionals.SecUid.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// TikTokWebAPIApiFetchUserProfileApiV1TiktokWebFetchUserProfileGet_25Opts Optional parameters for the method 'FetchUserProfileApiV1TiktokWebFetchUserProfileGet_25'
type TikTokWebAPIApiFetchUserProfileApiV1TiktokWebFetchUserProfileGet_25Opts struct {
	UniqueId optional.String
	SecUid   optional.String
}

/*
FetchUserProfileApiV1TiktokWebFetchUserProfileGet_0 获取用户的个人信息/Get user profile
# [中文] ### 用途: - 获取用户的个人信息 ### 参数: - secUid: 用户secUid - uniqueId: 用户uniqueId - secUid和uniqueId至少提供一个, 优先使用uniqueId, 也就是用户主页的链接中的用户名。 ### 返回: - 用户的个人信息  # [English] ### Purpose: - Get user profile ### Parameters: - secUid: User secUid - uniqueId: User uniqueId - At least one of secUid and uniqueId is provided, and uniqueId is preferred, that is, the username in the user&#39;s homepage link. ### Return: - User profile  # [示例/Example] secUid &#x3D; \&quot;MS4wLjABAAAAv7iSuuXDJGDvJkmH_vz1qkDZYo1apxgzaxdBSeIuPiM\&quot; uniqueId &#x3D; \&quot;tiktok\&quot;
  - @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param optional nil or *TikTokWebAPIApiFetchUserProfileApiV1TiktokWebFetchUserProfileGet_25Opts - Optional Parameters:
  - @param "UniqueId" (optional.String) -  用户uniqueId/User uniqueId
  - @param "SecUid" (optional.String) -  用户secUid/User secUid

@return ResponseModel
*/
func (a *TikTokWebAPIApiService) FetchUserProfileApiV1TiktokWebFetchUserProfileGet_25(ctx _context.Context, localVarOptionals *TikTokWebAPIApiFetchUserProfileApiV1TiktokWebFetchUserProfileGet_25Opts) (ResponseModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResponseModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/tiktok/web/fetch_user_profile"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.UniqueId.IsSet() {
		localVarQueryParams.Add("uniqueId", parameterToString(localVarOptionals.UniqueId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SecUid.IsSet() {
		localVarQueryParams.Add("secUid", parameterToString(localVarOptionals.SecUid.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
GenerateRealMsTokenApiV1TiktokWebGenerateRealMsTokenGet 生成真实msToken/Generate real msToken
# [中文] ### 用途: - 生成真实msToken ### 返回: - 真实msToken  # [English] ### Purpose: - Generate real msToken ### Return: - Real msToken
  - @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().

@return ResponseModel
*/
func (a *TikTokWebAPIApiService) GenerateRealMsTokenApiV1TiktokWebGenerateRealMsTokenGet(ctx _context.Context) (ResponseModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResponseModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/tiktok/web/generate_real_msToken"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
GenerateRealMsTokenApiV1TiktokWebGenerateRealMsTokenGet_0 生成真实msToken/Generate real msToken
# [中文] ### 用途: - 生成真实msToken ### 返回: - 真实msToken  # [English] ### Purpose: - Generate real msToken ### Return: - Real msToken
  - @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().

@return ResponseModel
*/
func (a *TikTokWebAPIApiService) GenerateRealMsTokenApiV1TiktokWebGenerateRealMsTokenGet_26(ctx _context.Context) (ResponseModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResponseModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/tiktok/web/generate_real_msToken"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
GenerateTtwidApiV1TiktokWebGenerateTtwidGet 生成ttwid/Generate ttwid
# [中文] ### 用途: - 生成ttwid ### 参数: - cookie: 用户cookie ### 返回: - ttwid  # [English] ### Purpose: - Generate ttwid ### Parameters: - cookie: User cookie ### Return: - ttwid  # [示例/Example] cookie &#x3D; \&quot;Your_Cookie\&quot;
  - @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param cookie 用户cookie/User cookie

@return ResponseModel
*/
func (a *TikTokWebAPIApiService) GenerateTtwidApiV1TiktokWebGenerateTtwidGet(ctx _context.Context, cookie string) (ResponseModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResponseModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/tiktok/web/generate_ttwid"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	localVarQueryParams.Add("cookie", parameterToString(cookie, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
GenerateTtwidApiV1TiktokWebGenerateTtwidGet_0 生成ttwid/Generate ttwid
# [中文] ### 用途: - 生成ttwid ### 参数: - cookie: 用户cookie ### 返回: - ttwid  # [English] ### Purpose: - Generate ttwid ### Parameters: - cookie: User cookie ### Return: - ttwid  # [示例/Example] cookie &#x3D; \&quot;Your_Cookie\&quot;
  - @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param cookie 用户cookie/User cookie

@return ResponseModel
*/
func (a *TikTokWebAPIApiService) GenerateTtwidApiV1TiktokWebGenerateTtwidGet_27(ctx _context.Context, cookie string) (ResponseModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResponseModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/tiktok/web/generate_ttwid"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	localVarQueryParams.Add("cookie", parameterToString(cookie, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// TikTokWebAPIApiGenerateXbogusApiV1TiktokWebGenerateXbogusPostOpts Optional parameters for the method 'GenerateXbogusApiV1TiktokWebGenerateXbogusPost'
type TikTokWebAPIApiGenerateXbogusApiV1TiktokWebGenerateXbogusPostOpts struct {
	XBogusModel optional.Interface
}

/*
GenerateXbogusApiV1TiktokWebGenerateXbogusPost 生成xbogus/Generate xbogus
# [中文] ### 用途: - 生成xbogus ### 参数: - url: 未签名的API URL - user_agent: 用户浏览器User-Agent ### 返回: - xbogus  # [English] ### Purpose: - Generate xbogus ### Parameters: - url: Unsigned API URL - user_agent: User browser User-Agent ### Return: - xbogus  # [示例/Example]  &#x60;&#x60;&#x60;json {     \&quot;url\&quot;: \&quot;https://www.douyin.com/aweme/v1/web/aweme/detail/?aweme_id&#x3D;7148736076176215311&amp;device_platform&#x3D;webapp&amp;aid&#x3D;6383&amp;channel&#x3D;channel_pc_web&amp;pc_client_type&#x3D;1&amp;version_code&#x3D;170400&amp;version_name&#x3D;17.4.0&amp;cookie_enabled&#x3D;true&amp;screen_width&#x3D;1920&amp;screen_height&#x3D;1080&amp;browser_language&#x3D;zh-CN&amp;browser_platform&#x3D;Win32&amp;browser_name&#x3D;Edge&amp;browser_version&#x3D;117.0.2045.47&amp;browser_online&#x3D;true&amp;engine_name&#x3D;Blink&amp;engine_version&#x3D;117.0.0.0&amp;os_name&#x3D;Windows&amp;os_version&#x3D;10&amp;cpu_core_num&#x3D;128&amp;device_memory&#x3D;10240&amp;platform&#x3D;PC&amp;downlink&#x3D;10&amp;effective_type&#x3D;4g&amp;round_trip_time&#x3D;100\&quot;,     \&quot;user_agent\&quot;: \&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.212 Safari/537.36\&quot; }
  - @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param optional nil or *TikTokWebAPIApiGenerateXbogusApiV1TiktokWebGenerateXbogusPostOpts - Optional Parameters:
  - @param "XBogusModel" (optional.Interface of XBogusModel) -

@return ResponseModel
*/
func (a *TikTokWebAPIApiService) GenerateXbogusApiV1TiktokWebGenerateXbogusPost(ctx _context.Context, localVarOptionals *TikTokWebAPIApiGenerateXbogusApiV1TiktokWebGenerateXbogusPostOpts) (ResponseModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResponseModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/tiktok/web/generate_xbogus"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.XBogusModel.IsSet() {
		localVarOptionalXBogusModel, localVarOptionalXBogusModelok := localVarOptionals.XBogusModel.Value().(XBogusModel)
		if !localVarOptionalXBogusModelok {
			return localVarReturnValue, nil, reportError("xBogusModel should be XBogusModel")
		}
		localVarPostBody = &localVarOptionalXBogusModel
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// TikTokWebAPIApiGenerateXbogusApiV1TiktokWebGenerateXbogusPost_28Opts Optional parameters for the method 'GenerateXbogusApiV1TiktokWebGenerateXbogusPost_28'
type TikTokWebAPIApiGenerateXbogusApiV1TiktokWebGenerateXbogusPost_28Opts struct {
	XBogusModel optional.Interface
}

/*
GenerateXbogusApiV1TiktokWebGenerateXbogusPost_0 生成xbogus/Generate xbogus
# [中文] ### 用途: - 生成xbogus ### 参数: - url: 未签名的API URL - user_agent: 用户浏览器User-Agent ### 返回: - xbogus  # [English] ### Purpose: - Generate xbogus ### Parameters: - url: Unsigned API URL - user_agent: User browser User-Agent ### Return: - xbogus  # [示例/Example]  &#x60;&#x60;&#x60;json {     \&quot;url\&quot;: \&quot;https://www.douyin.com/aweme/v1/web/aweme/detail/?aweme_id&#x3D;7148736076176215311&amp;device_platform&#x3D;webapp&amp;aid&#x3D;6383&amp;channel&#x3D;channel_pc_web&amp;pc_client_type&#x3D;1&amp;version_code&#x3D;170400&amp;version_name&#x3D;17.4.0&amp;cookie_enabled&#x3D;true&amp;screen_width&#x3D;1920&amp;screen_height&#x3D;1080&amp;browser_language&#x3D;zh-CN&amp;browser_platform&#x3D;Win32&amp;browser_name&#x3D;Edge&amp;browser_version&#x3D;117.0.2045.47&amp;browser_online&#x3D;true&amp;engine_name&#x3D;Blink&amp;engine_version&#x3D;117.0.0.0&amp;os_name&#x3D;Windows&amp;os_version&#x3D;10&amp;cpu_core_num&#x3D;128&amp;device_memory&#x3D;10240&amp;platform&#x3D;PC&amp;downlink&#x3D;10&amp;effective_type&#x3D;4g&amp;round_trip_time&#x3D;100\&quot;,     \&quot;user_agent\&quot;: \&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.212 Safari/537.36\&quot; }
  - @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param optional nil or *TikTokWebAPIApiGenerateXbogusApiV1TiktokWebGenerateXbogusPost_28Opts - Optional Parameters:
  - @param "XBogusModel" (optional.Interface of XBogusModel) -

@return ResponseModel
*/
func (a *TikTokWebAPIApiService) GenerateXbogusApiV1TiktokWebGenerateXbogusPost_28(ctx _context.Context, localVarOptionals *TikTokWebAPIApiGenerateXbogusApiV1TiktokWebGenerateXbogusPost_28Opts) (ResponseModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResponseModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/tiktok/web/generate_xbogus"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.XBogusModel.IsSet() {
		localVarOptionalXBogusModel, localVarOptionalXBogusModelok := localVarOptionals.XBogusModel.Value().(XBogusModel)
		if !localVarOptionalXBogusModelok {
			return localVarReturnValue, nil, reportError("xBogusModel should be XBogusModel")
		}
		localVarPostBody = &localVarOptionalXBogusModel
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// TikTokWebAPIApiGetAllAwemeIdApiV1TiktokWebGetAllAwemeIdPostOpts Optional parameters for the method 'GetAllAwemeIdApiV1TiktokWebGetAllAwemeIdPost'
type TikTokWebAPIApiGetAllAwemeIdApiV1TiktokWebGetAllAwemeIdPostOpts struct {
	RequestBody optional.Interface
}

/*
GetAllAwemeIdApiV1TiktokWebGetAllAwemeIdPost 提取列表作品id/Extract list video id
# [中文] ### 用途: - 提取列表作品id ### 参数: - url: 作品链接 (最多支持20个链接) ### 返回: - 作品id  # [English] ### Purpose: - Extract list video id ### Parameters: - url: Video link (Support up to 20 links) ### Return: - Video id  # [示例/Example] url &#x3D; [\&quot;https://www.tiktok.com/@owlcitymusic/video/7218694761253735723\&quot;]
  - @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param optional nil or *TikTokWebAPIApiGetAllAwemeIdApiV1TiktokWebGetAllAwemeIdPostOpts - Optional Parameters:
  - @param "RequestBody" (optional.Interface of []string) -

@return ResponseModel
*/
func (a *TikTokWebAPIApiService) GetAllAwemeIdApiV1TiktokWebGetAllAwemeIdPost(ctx _context.Context, localVarOptionals *TikTokWebAPIApiGetAllAwemeIdApiV1TiktokWebGetAllAwemeIdPostOpts) (ResponseModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResponseModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/tiktok/web/get_all_aweme_id"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.RequestBody.IsSet() {
		localVarOptionalRequestBody, localVarOptionalRequestBodyok := localVarOptionals.RequestBody.Value().([]string)
		if !localVarOptionalRequestBodyok {
			return localVarReturnValue, nil, reportError("requestBody should be []string")
		}
		localVarPostBody = &localVarOptionalRequestBody
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// TikTokWebAPIApiGetAllAwemeIdApiV1TiktokWebGetAllAwemeIdPost_29Opts Optional parameters for the method 'GetAllAwemeIdApiV1TiktokWebGetAllAwemeIdPost_29'
type TikTokWebAPIApiGetAllAwemeIdApiV1TiktokWebGetAllAwemeIdPost_29Opts struct {
	RequestBody optional.Interface
}

/*
GetAllAwemeIdApiV1TiktokWebGetAllAwemeIdPost_0 提取列表作品id/Extract list video id
# [中文] ### 用途: - 提取列表作品id ### 参数: - url: 作品链接 (最多支持20个链接) ### 返回: - 作品id  # [English] ### Purpose: - Extract list video id ### Parameters: - url: Video link (Support up to 20 links) ### Return: - Video id  # [示例/Example] url &#x3D; [\&quot;https://www.tiktok.com/@owlcitymusic/video/7218694761253735723\&quot;]
  - @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param optional nil or *TikTokWebAPIApiGetAllAwemeIdApiV1TiktokWebGetAllAwemeIdPost_29Opts - Optional Parameters:
  - @param "RequestBody" (optional.Interface of []string) -

@return ResponseModel
*/
func (a *TikTokWebAPIApiService) GetAllAwemeIdApiV1TiktokWebGetAllAwemeIdPost_29(ctx _context.Context, localVarOptionals *TikTokWebAPIApiGetAllAwemeIdApiV1TiktokWebGetAllAwemeIdPost_29Opts) (ResponseModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResponseModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/tiktok/web/get_all_aweme_id"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.RequestBody.IsSet() {
		localVarOptionalRequestBody, localVarOptionalRequestBodyok := localVarOptionals.RequestBody.Value().([]string)
		if !localVarOptionalRequestBodyok {
			return localVarReturnValue, nil, reportError("requestBody should be []string")
		}
		localVarPostBody = &localVarOptionalRequestBody
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// TikTokWebAPIApiGetAllSecUserIdApiV1TiktokWebGetAllSecUserIdPostOpts Optional parameters for the method 'GetAllSecUserIdApiV1TiktokWebGetAllSecUserIdPost'
type TikTokWebAPIApiGetAllSecUserIdApiV1TiktokWebGetAllSecUserIdPostOpts struct {
	RequestBody optional.Interface
}

/*
GetAllSecUserIdApiV1TiktokWebGetAllSecUserIdPost 提取列表用户sec_user_id/Extract list user sec_user_id
# [中文] ### 用途: - 提取列表用户id ### 参数: - url: 用户主页链接（最多支持10个链接）、 ### 返回: - 如果链接成功获取到sec_user_id，则返回sec_user_id，否则返回原始的输入链接，后续可以手动校验链接无法获取sec_user_id的原因。  # [English] ### Purpose: - Extract list user id ### Parameters: - url: User homepage link (Support up to 10 links) ### Return: - If the sec_user_id is successfully obtained, the sec_user_id is returned, otherwise the original input link is returned, and the reason why the sec_user_id cannot be obtained can be manually verified later.  # [示例/Example] url &#x3D; [\&quot;https://www.tiktok.com/@tiktok\&quot;]
  - @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param optional nil or *TikTokWebAPIApiGetAllSecUserIdApiV1TiktokWebGetAllSecUserIdPostOpts - Optional Parameters:
  - @param "RequestBody" (optional.Interface of []string) -

@return ResponseModel
*/
func (a *TikTokWebAPIApiService) GetAllSecUserIdApiV1TiktokWebGetAllSecUserIdPost(ctx _context.Context, localVarOptionals *TikTokWebAPIApiGetAllSecUserIdApiV1TiktokWebGetAllSecUserIdPostOpts) (ResponseModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResponseModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/tiktok/web/get_all_sec_user_id"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.RequestBody.IsSet() {
		localVarOptionalRequestBody, localVarOptionalRequestBodyok := localVarOptionals.RequestBody.Value().([]string)
		if !localVarOptionalRequestBodyok {
			return localVarReturnValue, nil, reportError("requestBody should be []string")
		}
		localVarPostBody = &localVarOptionalRequestBody
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// TikTokWebAPIApiGetAllSecUserIdApiV1TiktokWebGetAllSecUserIdPost_30Opts Optional parameters for the method 'GetAllSecUserIdApiV1TiktokWebGetAllSecUserIdPost_30'
type TikTokWebAPIApiGetAllSecUserIdApiV1TiktokWebGetAllSecUserIdPost_30Opts struct {
	RequestBody optional.Interface
}

/*
GetAllSecUserIdApiV1TiktokWebGetAllSecUserIdPost_0 提取列表用户sec_user_id/Extract list user sec_user_id
# [中文] ### 用途: - 提取列表用户id ### 参数: - url: 用户主页链接（最多支持10个链接）、 ### 返回: - 如果链接成功获取到sec_user_id，则返回sec_user_id，否则返回原始的输入链接，后续可以手动校验链接无法获取sec_user_id的原因。  # [English] ### Purpose: - Extract list user id ### Parameters: - url: User homepage link (Support up to 10 links) ### Return: - If the sec_user_id is successfully obtained, the sec_user_id is returned, otherwise the original input link is returned, and the reason why the sec_user_id cannot be obtained can be manually verified later.  # [示例/Example] url &#x3D; [\&quot;https://www.tiktok.com/@tiktok\&quot;]
  - @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param optional nil or *TikTokWebAPIApiGetAllSecUserIdApiV1TiktokWebGetAllSecUserIdPost_30Opts - Optional Parameters:
  - @param "RequestBody" (optional.Interface of []string) -

@return ResponseModel
*/
func (a *TikTokWebAPIApiService) GetAllSecUserIdApiV1TiktokWebGetAllSecUserIdPost_30(ctx _context.Context, localVarOptionals *TikTokWebAPIApiGetAllSecUserIdApiV1TiktokWebGetAllSecUserIdPost_30Opts) (ResponseModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResponseModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/tiktok/web/get_all_sec_user_id"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.RequestBody.IsSet() {
		localVarOptionalRequestBody, localVarOptionalRequestBodyok := localVarOptionals.RequestBody.Value().([]string)
		if !localVarOptionalRequestBodyok {
			return localVarReturnValue, nil, reportError("requestBody should be []string")
		}
		localVarPostBody = &localVarOptionalRequestBody
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// TikTokWebAPIApiGetAllUniqueIdApiV1TiktokWebGetAllUniqueIdPostOpts Optional parameters for the method 'GetAllUniqueIdApiV1TiktokWebGetAllUniqueIdPost'
type TikTokWebAPIApiGetAllUniqueIdApiV1TiktokWebGetAllUniqueIdPostOpts struct {
	RequestBody optional.Interface
}

/*
GetAllUniqueIdApiV1TiktokWebGetAllUniqueIdPost 获取列表unique_id/Get list unique_id
# [中文] ### 用途: - 获取列表unique_id ### 参数: - url: 用户主页链接 (最多支持20个链接) ### 返回: - unique_id  # [English] ### Purpose: - Get list unique_id ### Parameters: - url: User homepage link (Support up to 20 links) ### Return: - unique_id  # [示例/Example] url &#x3D; [\&quot;https://www.tiktok.com/@tiktok\&quot;]
  - @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param optional nil or *TikTokWebAPIApiGetAllUniqueIdApiV1TiktokWebGetAllUniqueIdPostOpts - Optional Parameters:
  - @param "RequestBody" (optional.Interface of []string) -

@return ResponseModel
*/
func (a *TikTokWebAPIApiService) GetAllUniqueIdApiV1TiktokWebGetAllUniqueIdPost(ctx _context.Context, localVarOptionals *TikTokWebAPIApiGetAllUniqueIdApiV1TiktokWebGetAllUniqueIdPostOpts) (ResponseModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResponseModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/tiktok/web/get_all_unique_id"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.RequestBody.IsSet() {
		localVarOptionalRequestBody, localVarOptionalRequestBodyok := localVarOptionals.RequestBody.Value().([]string)
		if !localVarOptionalRequestBodyok {
			return localVarReturnValue, nil, reportError("requestBody should be []string")
		}
		localVarPostBody = &localVarOptionalRequestBody
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// TikTokWebAPIApiGetAllUniqueIdApiV1TiktokWebGetAllUniqueIdPost_31Opts Optional parameters for the method 'GetAllUniqueIdApiV1TiktokWebGetAllUniqueIdPost_31'
type TikTokWebAPIApiGetAllUniqueIdApiV1TiktokWebGetAllUniqueIdPost_31Opts struct {
	RequestBody optional.Interface
}

/*
GetAllUniqueIdApiV1TiktokWebGetAllUniqueIdPost_0 获取列表unique_id/Get list unique_id
# [中文] ### 用途: - 获取列表unique_id ### 参数: - url: 用户主页链接 (最多支持20个链接) ### 返回: - unique_id  # [English] ### Purpose: - Get list unique_id ### Parameters: - url: User homepage link (Support up to 20 links) ### Return: - unique_id  # [示例/Example] url &#x3D; [\&quot;https://www.tiktok.com/@tiktok\&quot;]
  - @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param optional nil or *TikTokWebAPIApiGetAllUniqueIdApiV1TiktokWebGetAllUniqueIdPost_31Opts - Optional Parameters:
  - @param "RequestBody" (optional.Interface of []string) -

@return ResponseModel
*/
func (a *TikTokWebAPIApiService) GetAllUniqueIdApiV1TiktokWebGetAllUniqueIdPost_31(ctx _context.Context, localVarOptionals *TikTokWebAPIApiGetAllUniqueIdApiV1TiktokWebGetAllUniqueIdPost_31Opts) (ResponseModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResponseModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/tiktok/web/get_all_unique_id"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.RequestBody.IsSet() {
		localVarOptionalRequestBody, localVarOptionalRequestBodyok := localVarOptionals.RequestBody.Value().([]string)
		if !localVarOptionalRequestBodyok {
			return localVarReturnValue, nil, reportError("requestBody should be []string")
		}
		localVarPostBody = &localVarOptionalRequestBody
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
GetAwemeIdApiV1TiktokWebGetAwemeIdGet 提取单个作品id/Extract single video id
# [中文] ### 用途: - 提取单个作品id ### 参数: - url: 作品链接 ### 返回: - 作品id  # [English] ### Purpose: - Extract single video id ### Parameters: - url: Video link ### Return: - Video id  # [示例/Example] url &#x3D; \&quot;https://www.tiktok.com/@owlcitymusic/video/7218694761253735723\&quot;
  - @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param url 作品链接/Video link

@return ResponseModel
*/
func (a *TikTokWebAPIApiService) GetAwemeIdApiV1TiktokWebGetAwemeIdGet(ctx _context.Context, url string) (ResponseModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResponseModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/tiktok/web/get_aweme_id"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	localVarQueryParams.Add("url", parameterToString(url, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
GetAwemeIdApiV1TiktokWebGetAwemeIdGet_0 提取单个作品id/Extract single video id
# [中文] ### 用途: - 提取单个作品id ### 参数: - url: 作品链接 ### 返回: - 作品id  # [English] ### Purpose: - Extract single video id ### Parameters: - url: Video link ### Return: - Video id  # [示例/Example] url &#x3D; \&quot;https://www.tiktok.com/@owlcitymusic/video/7218694761253735723\&quot;
  - @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param url 作品链接/Video link

@return ResponseModel
*/
func (a *TikTokWebAPIApiService) GetAwemeIdApiV1TiktokWebGetAwemeIdGet_32(ctx _context.Context, url string) (ResponseModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResponseModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/tiktok/web/get_aweme_id"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	localVarQueryParams.Add("url", parameterToString(url, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
GetLiveRoomIdApiV1TiktokWebGetLiveRoomIdGet 根据直播间链接提取直播间ID/Extract live room ID from live room link
# [中文] ### 用途: - 根据直播间链接提取直播间Room ID - 支持短链接，如：https://vt.tiktok.com/ZSjuyJnWQ/ - 支持长链接，如：https://www.tiktok.com/@maksukaracun/live ### 参数: - live_room_url: 直播间链接 ### 返回: - 直播间Room ID  # [English] ### Purpose: - Extract live room Room ID from live room link - Support short links, such as: https://vt.tiktok.com/ZSjuyJnWQ/ - Support long links, such as: https://www.tiktok.com/@maksukaracun/live ### Parameters: - live_room_url: Live room link ### Return: - Live room Room ID  # [示例/Example] live_room_url &#x3D; \&quot;https://www.tiktok.com/@maksukaracun/live\&quot;
  - @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param liveRoomUrl 直播间链接/Live room link

@return ResponseModel
*/
func (a *TikTokWebAPIApiService) GetLiveRoomIdApiV1TiktokWebGetLiveRoomIdGet(ctx _context.Context, liveRoomUrl string) (ResponseModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResponseModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/tiktok/web/get_live_room_id"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	localVarQueryParams.Add("live_room_url", parameterToString(liveRoomUrl, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
GetLiveRoomIdApiV1TiktokWebGetLiveRoomIdGet_0 根据直播间链接提取直播间ID/Extract live room ID from live room link
# [中文] ### 用途: - 根据直播间链接提取直播间Room ID - 支持短链接，如：https://vt.tiktok.com/ZSjuyJnWQ/ - 支持长链接，如：https://www.tiktok.com/@maksukaracun/live ### 参数: - live_room_url: 直播间链接 ### 返回: - 直播间Room ID  # [English] ### Purpose: - Extract live room Room ID from live room link - Support short links, such as: https://vt.tiktok.com/ZSjuyJnWQ/ - Support long links, such as: https://www.tiktok.com/@maksukaracun/live ### Parameters: - live_room_url: Live room link ### Return: - Live room Room ID  # [示例/Example] live_room_url &#x3D; \&quot;https://www.tiktok.com/@maksukaracun/live\&quot;
  - @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param liveRoomUrl 直播间链接/Live room link

@return ResponseModel
*/
func (a *TikTokWebAPIApiService) GetLiveRoomIdApiV1TiktokWebGetLiveRoomIdGet_33(ctx _context.Context, liveRoomUrl string) (ResponseModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResponseModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/tiktok/web/get_live_room_id"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	localVarQueryParams.Add("live_room_url", parameterToString(liveRoomUrl, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
GetSecUserIdApiV1TiktokWebGetSecUserIdGet 提取用户sec_user_id/Extract user sec_user_id
# [中文] ### 用途: - 提取列表用户id ### 参数: - url: 用户主页链接 ### 返回: - 用户id  # [English] ### Purpose: - Extract list user id ### Parameters: - url: User homepage link ### Return: - User id  # [示例/Example] url &#x3D; \&quot;https://www.tiktok.com/@tiktok\&quot;
  - @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param url 用户主页链接/User homepage link

@return ResponseModel
*/
func (a *TikTokWebAPIApiService) GetSecUserIdApiV1TiktokWebGetSecUserIdGet(ctx _context.Context, url string) (ResponseModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResponseModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/tiktok/web/get_sec_user_id"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	localVarQueryParams.Add("url", parameterToString(url, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
GetSecUserIdApiV1TiktokWebGetSecUserIdGet_0 提取用户sec_user_id/Extract user sec_user_id
# [中文] ### 用途: - 提取列表用户id ### 参数: - url: 用户主页链接 ### 返回: - 用户id  # [English] ### Purpose: - Extract list user id ### Parameters: - url: User homepage link ### Return: - User id  # [示例/Example] url &#x3D; \&quot;https://www.tiktok.com/@tiktok\&quot;
  - @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param url 用户主页链接/User homepage link

@return ResponseModel
*/
func (a *TikTokWebAPIApiService) GetSecUserIdApiV1TiktokWebGetSecUserIdGet_34(ctx _context.Context, url string) (ResponseModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResponseModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/tiktok/web/get_sec_user_id"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	localVarQueryParams.Add("url", parameterToString(url, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
GetUniqueIdApiV1TiktokWebGetUniqueIdGet 获取用户unique_id/Get user unique_id
# [中文] ### 用途: - 获取用户unique_id ### 参数: - url: 用户主页链接 ### 返回: - unique_id  # [English] ### Purpose: - Get user unique_id ### Parameters: - url: User homepage link ### Return: - unique_id  # [示例/Example] url &#x3D; \&quot;https://www.tiktok.com/@tiktok\&quot;
  - @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param url 用户主页链接/User homepage link

@return ResponseModel
*/
func (a *TikTokWebAPIApiService) GetUniqueIdApiV1TiktokWebGetUniqueIdGet(ctx _context.Context, url string) (ResponseModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResponseModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/tiktok/web/get_unique_id"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	localVarQueryParams.Add("url", parameterToString(url, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
GetUniqueIdApiV1TiktokWebGetUniqueIdGet_0 获取用户unique_id/Get user unique_id
# [中文] ### 用途: - 获取用户unique_id ### 参数: - url: 用户主页链接 ### 返回: - unique_id  # [English] ### Purpose: - Get user unique_id ### Parameters: - url: User homepage link ### Return: - unique_id  # [示例/Example] url &#x3D; \&quot;https://www.tiktok.com/@tiktok\&quot;
  - @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param url 用户主页链接/User homepage link

@return ResponseModel
*/
func (a *TikTokWebAPIApiService) GetUniqueIdApiV1TiktokWebGetUniqueIdGet_35(ctx _context.Context, url string) (ResponseModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResponseModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/tiktok/web/get_unique_id"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	localVarQueryParams.Add("url", parameterToString(url, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
